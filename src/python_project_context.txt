

================================================================================
File Path: .\config.py
================================================================================

"""
설정 관리 모듈
환경 변수 및 기본 설정을 로드합니다.
프로젝트 루트의 .env 파일을 자동으로 로드합니다.
"""

import os
from pathlib import Path
from typing import Optional

from dotenv import load_dotenv

# 프로젝트 루트 경로 찾기 (src/config.py에서 상위 디렉토리)
_project_root = Path(__file__).parent.parent
_env_path = _project_root / ".env"

# .env 파일이 있으면 자동으로 로드
if _env_path.exists():
    load_dotenv(_env_path, override=False)  # override=False: 기존 환경 변수 우선
    print(f"[Config] .env 파일 로드됨: {_env_path}")
else:
    # .env 파일이 없어도 기본값으로 동작
    print(f"[Config] .env 파일을 찾을 수 없습니다. 기본값을 사용합니다: {_env_path}")


class Config:
    """애플리케이션 설정 클래스"""
    
    # Ollama 설정
    OLLAMA_URL: str = os.getenv("OLLAMA_URL", "http://localhost:11434")
    OLLAMA_MODEL: str = os.getenv("OLLAMA_MODEL", "deepseek-r1:14b")
    OLLAMA_TEMPERATURE: float = float(os.getenv("OLLAMA_TEMPERATURE", "0.7"))
    
    # ComfyUI 설정
    COMFYUI_URL: str = os.getenv("COMFYUI_URL", "http://127.0.0.1:8188")
    COMFYUI_WS_URL: str = os.getenv("COMFYUI_WS_URL", "ws://127.0.0.1:8188/ws")
    COMFYUI_WORKFLOW_PATH: str = os.getenv("COMFYUI_WORKFLOW_PATH", "comfyui_workflow.json")
    COMFYUI_TIMEOUT: int = int(os.getenv("COMFYUI_TIMEOUT", "300"))
    COMFYUI_RETRY_COUNT: int = int(os.getenv("COMFYUI_RETRY_COUNT", "2"))
    COMFYUI_USE_MOCK: bool = os.getenv("COMFYUI_USE_MOCK", "false").lower() == "true"  # 테스트용 더미 이미지 생성
    COMFYUI_API_KEY: str = os.getenv("COMFYUI_API_KEY", "")  # ComfyUI API 키 (선택사항)
    COMFYUI_CHECKPOINT: str = os.getenv("COMFYUI_CHECKPOINT", "")  # 사용할 체크포인트 모델명 (선택사항)
    
    # 출력 설정
    OUTPUT_DIR: str = os.getenv("OUTPUT_DIR", "output")
    
    # 비디오 설정
    VIDEO_FPS: int = int(os.getenv("VIDEO_FPS", "24"))
    VIDEO_CODEC: str = os.getenv("VIDEO_CODEC", "libx264")
    VIDEO_AUDIO_CODEC: str = os.getenv("VIDEO_AUDIO_CODEC", "aac")
    ZOOM_FACTOR: float = float(os.getenv("ZOOM_FACTOR", "1.15"))
    
    # TTS 설정
    TTS_VOICE: str = os.getenv("TTS_VOICE", "ko-KR-InJoonNeural")
    
    # Wan2.2 I2V 모션 생성 설정
    MOTION_ENABLED: bool = os.getenv("MOTION_ENABLED", "true").lower() == "true"  # 모션 생성 활성화 여부
    MOTION_FPS: int = int(os.getenv("MOTION_FPS", "12"))  # 모션 프레임레이트
    MOTION_DURATION: float = float(os.getenv("MOTION_DURATION", "3.0"))  # 장면당 모션 길이 (초)
    MOTION_MODEL_TYPE: str = os.getenv("MOTION_MODEL_TYPE", "wan2.2_distill")  # 모션 모델 타입
    I2V_NODE_TYPE: str = os.getenv("I2V_NODE_TYPE", "WanImageToVideo")  # I2V 노드 타입 (WanImageToVideo 기본값)
    I2V_STEPS: int = int(os.getenv("I2V_STEPS", "4"))  # I2V 추론 스텝 (Lightning/Distill 4-step)
    I2V_GUIDANCE: float = float(os.getenv("I2V_GUIDANCE", "3.5"))  # I2V Guidance 스케일
    # Wan2.2 모델 파일명 (JSON 워크플로우 기반)
    I2V_CLIP_NAME: str = os.getenv("I2V_CLIP_NAME", "umt5_xxl_fp8_e4m3fn_scaled.safetensors")  # CLIP 텍스트 인코더
    I2V_VAE_NAME: str = os.getenv("I2V_VAE_NAME", "wan_2.1_vae.safetensors")  # VAE 모델
    I2V_UNET_NAME: str = os.getenv("I2V_UNET_NAME", "wan2.2_i2v_high_noise_14B_fp8_scaled.safetensors")  # UNet 모델 (high_noise)
    I2V_MODEL_SAMPLING_SHIFT: float = float(os.getenv("I2V_MODEL_SAMPLING_SHIFT", "8.0"))  # ModelSamplingSD3 shift 값
    
    @classmethod
    def get_output_dir(cls, topic: str = None) -> Path:
        """
        출력 디렉토리 경로를 반환하고 생성합니다.
        
        Args:
            topic: 주제명 (지정 시 주제별 폴더 생성)
        
        Returns:
            출력 디렉토리 Path
        """
        output_path = Path(cls.OUTPUT_DIR)
        
        # 주제가 지정되면 주제별 폴더 생성
        if topic:
            # 파일명에 사용할 수 없는 문자 제거
            safe_topic = "".join(c for c in topic if c.isalnum() or c in (' ', '-', '_')).strip()
            if safe_topic:
                output_path = output_path / safe_topic
        
        output_path.mkdir(parents=True, exist_ok=True)
        return output_path
    
    @classmethod
    def validate(cls) -> None:
        """설정값 검증"""
        if not cls.OLLAMA_URL.startswith(("http://", "https://")):
            raise ValueError(f"잘못된 OLLAMA_URL 형식: {cls.OLLAMA_URL}")
        if not cls.COMFYUI_URL.startswith(("http://", "https://")):
            raise ValueError(f"잘못된 COMFYUI_URL 형식: {cls.COMFYUI_URL}")



================================================================================
File Path: .\main.py
================================================================================

"""
YouTube Shorts 자동 생성 에이전트 - 메인 엔트리 포인트
입력 → 그래프 실행 → 출력만 담당합니다.
"""

import argparse
import logging
import sys
from pathlib import Path

# 프로젝트 루트를 sys.path에 추가
project_root = Path(__file__).parent.parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

from src.config import Config
from src.utils.logger import setup_logger
from src.utils.cache import init_cache
from src.workflow.graph import create_video_graph_simple, VideoState

# 로거 설정
logger = setup_logger()


def parse_args():
    """명령행 인자 파싱"""
    parser = argparse.ArgumentParser(description="YouTube Shorts 자동 생성 에이전트")
    parser.add_argument("--topic", "-t", type=str, default="ai의 미래", help="비디오 주제")
    parser.add_argument("--no-cache", action="store_true", help="캐시 사용 안 함 (처음부터 새로 생성)")
    parser.add_argument("--clear-cache", action="store_true", help="캐시 초기화 후 실행")
    return parser.parse_args()


def main():
    """메인 실행 함수"""
    args = parse_args()
    
    logger.info("=" * 60)
    logger.info("YouTube Shorts 자동 생성 에이전트")
    logger.info("=" * 60)
    
    try:
        # 설정 검증
        Config.validate()
        logger.info("설정 검증 완료")
        
        # 캐시 초기화
        cache = init_cache(args.topic)
        
        if args.clear_cache:
            cache.clear()
            logger.info("캐시가 초기화되었습니다.")
        elif args.no_cache:
            cache.clear()
            logger.info("캐시 사용 안 함 모드")
        else:
            # 캐시 상태 출력
            status = cache.get_status()
            cached_stages = [k for k, v in status.items() if v]
            if cached_stages:
                logger.info(f"캐시된 단계: {', '.join(cached_stages)}")
        
        # 초기 상태 설정
        initial_state: VideoState = {
            "topic": args.topic,
            "scenes": [],
            "final_video_path": ""
        }
        
        # 그래프 생성
        logger.info("워크플로우 그래프 생성 중...")
        graph = create_video_graph_simple()
        
        # 그래프 실행
        logger.info(f"주제: {initial_state['topic']}")
        logger.info("워크플로우 시작...\n")
        
        final_state = graph.invoke(initial_state)
        
        # 결과 출력
        logger.info("\n" + "=" * 60)
        logger.info("워크플로우 완료!")
        logger.info("=" * 60)
        logger.info(f"최종 비디오 경로: {final_state['final_video_path']}")
        logger.info(f"생성된 장면 수: {len(final_state['scenes'])}")
        
        return 0
        
    except KeyboardInterrupt:
        logger.warning("\n사용자에 의해 중단되었습니다.")
        return 130
        
    except Exception as e:
        logger.error(f"\n오류 발생: {e}", exc_info=True)
        return 1


if __name__ == "__main__":
    sys.exit(main())


================================================================================
File Path: .\python_project_context.txt
================================================================================



================================================================================
File Path: .\config.py
================================================================================

"""
설정 관리 모듈
환경 변수 및 기본 설정을 로드합니다.
프로젝트 루트의 .env 파일을 자동으로 로드합니다.
"""

import os
from pathlib import Path
from typing import Optional

from dotenv import load_dotenv

# 프로젝트 루트 경로 찾기 (src/config.py에서 상위 디렉토리)
_project_root = Path(__file__).parent.parent
_env_path = _project_root / ".env"

# .env 파일이 있으면 자동으로 로드
if _env_path.exists():
    load_dotenv(_env_path, override=False)  # override=False: 기존 환경 변수 우선
    print(f"[Config] .env 파일 로드됨: {_env_path}")
else:
    # .env 파일이 없어도 기본값으로 동작
    print(f"[Config] .env 파일을 찾을 수 없습니다. 기본값을 사용합니다: {_env_path}")


class Config:
    """애플리케이션 설정 클래스"""
    
    # Ollama 설정
    OLLAMA_URL: str = os.getenv("OLLAMA_URL", "http://localhost:11434")
    OLLAMA_MODEL: str = os.getenv("OLLAMA_MODEL", "deepseek-r1:14b")
    OLLAMA_TEMPERATURE: float = float(os.getenv("OLLAMA_TEMPERATURE", "0.7"))
    
    # ComfyUI 설정
    COMFYUI_URL: str = os.getenv("COMFYUI_URL", "http://127.0.0.1:8188")
    COMFYUI_WS_URL: str = os.getenv("COMFYUI_WS_URL", "ws://127.0.0.1:8188/ws")
    COMFYUI_WORKFLOW_PATH: str = os.getenv("COMFYUI_WORKFLOW_PATH", "comfyui_workflow.json")
    COMFYUI_TIMEOUT: int = int(os.getenv("COMFYUI_TIMEOUT", "300"))
    COMFYUI_RETRY_COUNT: int = int(os.getenv("COMFYUI_RETRY_COUNT", "2"))
    COMFYUI_USE_MOCK: bool = os.getenv("COMFYUI_USE_MOCK", "false").lower() == "true"  # 테스트용 더미 이미지 생성
    COMFYUI_API_KEY: str = os.getenv("COMFYUI_API_KEY", "")  # ComfyUI API 키 (선택사항)
    COMFYUI_CHECKPOINT: str = os.getenv("COMFYUI_CHECKPOINT", "")  # 사용할 체크포인트 모델명 (선택사항)
    
    # 출력 설정
    OUTPUT_DIR: str = os.getenv("OUTPUT_DIR", "output")
    
    # 비디오 설정
    VIDEO_FPS: int = int(os.getenv("VIDEO_FPS", "24"))
    VIDEO_CODEC: str = os.getenv("VIDEO_CODEC", "libx264")
    VIDEO_AUDIO_CODEC: str = os.getenv("VIDEO_AUDIO_CODEC", "aac")
    ZOOM_FACTOR: float = float(os.getenv("ZOOM_FACTOR", "1.15"))
    
    # TTS 설정
    TTS_VOICE: str = os.getenv("TTS_VOICE", "ko-KR-InJoonNeural")
    
    # Wan2.2 I2V 모션 생성 설정
    MOTION_ENABLED: bool = os.getenv("MOTION_ENABLED", "true").lower() == "true"  # 모션 생성 활성화 여부
    MOTION_FPS: int = int(os.getenv("MOTION_FPS", "12"))  # 모션 프레임레이트
    MOTION_DURATION: float = float(os.getenv("MOTION_DURATION", "3.0"))  # 장면당 모션 길이 (초)
    MOTION_MODEL_TYPE: str = os.getenv("MOTION_MODEL_TYPE", "wan2.2_distill")  # 모션 모델 타입
    I2V_NODE_TYPE: str = os.getenv("I2V_NODE_TYPE", "WanImageToVideo")  # I2V 노드 타입 (WanImageToVideo 기본값)
    I2V_STEPS: int = int(os.getenv("I2V_STEPS", "4"))  # I2V 추론 스텝 (Lightning/Distill 4-step)
    I2V_GUIDANCE: float = float(os.getenv("I2V_GUIDANCE", "3.5"))  # I2V Guidance 스케일
    # Wan2.2 모델 파일명 (JSON 워크플로우 기반)
    I2V_CLIP_NAME: str = os.getenv("I2V_CLIP_NAME", "umt5_xxl_fp8_e4m3fn_scaled.safetensors")  # CLIP 텍스트 인코더
    I2V_VAE_NAME: str = os.getenv("I2V_VAE_NAME", "wan_2.1_vae.safetensors")  # VAE 모델
    I2V_UNET_NAME: str = os.getenv("I2V_UNET_NAME", "wan2.2_i2v_high_noise_14B_fp8_scaled.safetensors")  # UNet 모델 (high_noise)
    I2V_MODEL_SAMPLING_SHIFT: float = float(os.getenv("I2V_MODEL_SAMPLING_SHIFT", "8.0"))  # ModelSamplingSD3 shift 값
    
    @classmethod
    def get_output_dir(cls, topic: str = None) -> Path:
        """
        출력 디렉토리 경로를 반환하고 생성합니다.
        
        Args:
            topic: 주제명 (지정 시 주제별 폴더 생성)
        
        Returns:
            출력 디렉토리 Path
        """
        output_path = Path(cls.OUTPUT_DIR)
        
        # 주제가 지정되면 주제별 폴더 생성
        if topic:
            # 파일명에 사용할 수 없는 문자 제거
            safe_topic = "".join(c for c in topic if c.isalnum() or c in (' ', '-', '_')).strip()
            if safe_topic:
                output_path = output_path / safe_topic
        
        output_path.mkdir(parents=True, exist_ok=True)
        return output_path
    
    @classmethod
    def validate(cls) -> None:
        """설정값 검증"""
        if not cls.OLLAMA_URL.startswith(("http://", "https://")):
            raise ValueError(f"잘못된 OLLAMA_URL 형식: {cls.OLLAMA_URL}")
        if not cls.COMFYUI_URL.startswith(("http://", "https://")):
            raise ValueError(f"잘못된 COMFYUI_URL 형식: {cls.COMFYUI_URL}")



================================================================================
File Path: .\main.py
================================================================================

"""
YouTube Shorts 자동 생성 에이전트 - 메인 엔트리 포인트
입력 → 그래프 실행 → 출력만 담당합니다.
"""

import argparse
import logging
import sys
from pathlib import Path

# 프로젝트 루트를 sys.path에 추가
project_root = Path(__file__).parent.parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

from src.config import Config
from src.utils.logger import setup_logger
from src.utils.cache import init_cache
from src.workflow.graph import create_video_graph_simple, VideoState

# 로거 설정
logger = setup_logger()


def parse_args():
    """명령행 인자 파싱"""
    parser = argparse.ArgumentParser(description="YouTube Shorts 자동 생성 에이전트")
    parser.add_argument("--topic", "-t", type=str, default="ai의 미래", help="비디오 주제")
    parser.add_argument("--no-cache", action="store_true", help="캐시 사용 안 함 (처음부터 새로 생성)")
    parser.add_argument("--clear-cache", action="store_true", help="캐시 초기화 후 실행")
    return parser.parse_args()


def main():
    """메인 실행 함수"""
    args = parse_args()
    
    logger.info("=" * 60)
    logger.info("YouTube Shorts 자동 생성 에이전트")
    logger.info("=" * 60)
    
    try:
        # 설정 검증
        Config.validate()
        logger.info("설정 검증 완료")
        
        # 캐시 초기화
        cache = init_cache(args.topic)
        
        if args.clear_cache:
            cache.clear()
            logger.info("캐시가 초기화되었습니다.")
        elif args.no_cache:
            cache.clear()
            logger.info("캐시 사용 안 함 모드")
        else:
            # 캐시 상태 출력
            status = cache.get_status()
            cached_stages = [k for k, v in status.items() if v]
            if cached_stages:
                logger.info(f"캐시된 단계: {', '.join(cached_stages)}")
        
        # 초기 상태 설정
        initial_state: VideoState = {
            "topic": args.topic,
            "scenes": [],
            "final_video_path": ""
        }
        
        # 그래프 생성
        logger.info("워크플로우 그래프 생성 중...")
        graph = create_video_graph_simple()
        
        # 그래프 실행
        logger.info(f"주제: {initial_state['topic']}")
        logger.info("워크플로우 시작...\n")
        
        final_state = graph.invoke(initial_state)
        
        # 결과 출력
        logger.info("\n" + "=" * 60)
        logger.info("워크플로우 완료!")
        logger.info("=" * 60)
        logger.info(f"최종 비디오 경로: {final_state['final_video_path']}")
        logger.info(f"생성된 장면 수: {len(final_state['scenes'])}")
        
        return 0
        
    except KeyboardInterrupt:
        logger.warning("\n사용자에 의해 중단되었습니다.")
        return 130
        
    except Exception as e:
        logger.error(f"\n오류 발생: {e}", exc_info=True)
        return 1


if __name__ == "__main__":
    sys.exit(main())


================================================================================
File Path: .\py_merge.py
================================================================================

import os

# 설정: Python 프로젝트에 맞는 확장자와 무시할 폴더
TARGET_EXTENSIONS = {
    '.py',       # Python 소스 코드
    '.pyi',      # Python 타입 힌트
    '.pyx',      # Cython 소스 코드
    '.pyw',      # Python Windows 스크립트
    '.toml',     # pyproject.toml, poetry.lock 등
    '.yaml',     # YAML 설정 파일
    '.yml',      # YAML 설정 파일
    '.json',     # JSON 설정 파일
    '.md',       # 마크다운 문서
    '.txt',      # 텍스트 파일 (README 등)
    '.ini',      # INI 설정 파일
    '.cfg',      # 설정 파일
    '.env',      # 환경 변수 파일
    '.lock',     # uv.lock, poetry.lock 등
    '.yml',      # GitHub Actions 등
}

IGNORE_DIRS = {
    '.git',
    '__pycache__',  # Python 캐시 (중요)
    '.pytest_cache',  # pytest 캐시
    '.mypy_cache',   # mypy 캐시
    '.ruff_cache',   # ruff 캐시
    'venv',         # 가상 환경
    'env',          # 가상 환경
    '.venv',        # 가상 환경
    'node_modules', # Node.js 모듈
    'dist',         # 배포 파일
    'build',        # 빌드 파일
    '.tox',         # tox 테스트 환경
    'htmlcov',      # 커버리지 리포트
    '.coverage',    # 커버리지 데이터
    '.idea',        # PyCharm 설정
    '.vscode',      # VS Code 설정
    '.eggs',        # setuptools eggs
    '*.egg-info',   # 패키지 메타데이터
    '.hypothesis',  # hypothesis 테스트
    '.ipynb_checkpoints',  # Jupyter 체크포인트
    'logs',         # 로그 파일 디렉토리
    'output',       # 출력 디렉토리
}

def merge_project_files(output_filename="python_project_context.txt"):
    """
    Python 프로젝트의 모든 관련 파일을 하나의 텍스트 파일로 병합합니다.
    
    Args:
        output_filename: 출력 파일명
    """
    file_count = 0
    
    with open(output_filename, "w", encoding="utf-8") as outfile:
        # 프로젝트 루트부터 탐색
        for root, dirs, files in os.walk("."):
            # 무시할 폴더 제거 (inplace 수정)
            dirs[:] = [d for d in dirs if d not in IGNORE_DIRS and not d.startswith('.')]
            
            for file in files:
                # 숨김 파일 제외 (단, .env는 포함)
                if file.startswith('.') and file != '.env' and not file.endswith(('.py', '.toml', '.yaml', '.yml')):
                    continue
                
                ext = os.path.splitext(file)[1].lower()  # 확장자 대소문자 구분 없이 처리
                if ext in TARGET_EXTENSIONS:
                    file_path = os.path.join(root, file)
                    
                    # 무시할 디렉토리 경로에 포함되어 있는지 확인
                    if any(ignore_dir in file_path.split(os.sep) for ignore_dir in IGNORE_DIRS):
                        continue
                    
                    try:
                        with open(file_path, "r", encoding="utf-8", errors='ignore') as infile:
                            content = infile.read()
                            
                            # ★ 핵심: 파일 경로를 명확히 적어줌 (LLM이 파일 위치 인식용)
                            outfile.write(f"\n\n{'='*80}\n")
                            outfile.write(f"File Path: {file_path}\n")
                            outfile.write(f"{'='*80}\n\n")
                            outfile.write(content)
                            file_count += 1
                            print(f"Added: {file_path}")
                            
                    except UnicodeDecodeError:
                        print(f"Skipped {file_path} (binary or encoding issue)")
                    except Exception as e:
                        print(f"Skipped {file_path} due to error: {e}")

    print(f"\nDone! {file_count} Python project files merged into: {output_filename}")

if __name__ == "__main__":
    merge_project_files()

================================================================================
File Path: .\agents\script_writer.py
================================================================================

"""
대본 작성 에이전트
Ollama LLM을 사용하여 유튜브 쇼츠 대본을 생성합니다.
"""

import json
import logging
import os
import requests
from pathlib import Path
from typing import Dict, List

from src.config import Config
from src.utils.json_parser import extract_json_from_text

logger = logging.getLogger(__name__)


def call_ollama(prompt: str, model: str = None, temperature: float = None) -> str:
    """
    Ollama API를 직접 호출하여 LLM 응답을 받습니다.
    
    Args:
        prompt: 프롬프트 텍스트
        model: 모델 이름 (기본값: Config.OLLAMA_MODEL)
        temperature: 온도 설정 (기본값: Config.OLLAMA_TEMPERATURE)
        
    Returns:
        LLM 응답 텍스트
        
    Raises:
        requests.RequestException: API 호출 실패 시
        ValueError: 응답이 유효하지 않은 경우
    """
    model = model or Config.OLLAMA_MODEL
    temperature = temperature if temperature is not None else Config.OLLAMA_TEMPERATURE
    
    url = f"{Config.OLLAMA_URL}/api/generate"
    
    payload = {
        "model": model,
        "prompt": prompt,
        "stream": False,
        "options": {
            "temperature": temperature
        }
    }
    
    try:
        logger.info(f"Ollama API 호출: {model} (temperature: {temperature})")
        response = requests.post(url, json=payload, timeout=120)
        response.raise_for_status()
        
        result = response.json()
        
        if "response" not in result:
            raise ValueError(f"Ollama 응답에 'response' 키가 없습니다: {result}")
        
        content = result["response"]
        logger.debug(f"Ollama 응답 수신 (길이: {len(content)} 문자)")
        
        return content
        
    except requests.RequestException as e:
        logger.error(f"Ollama API 호출 실패: {e}")
        raise
    except json.JSONDecodeError as e:
        logger.error(f"Ollama 응답 JSON 파싱 실패: {e}")
        raise ValueError(f"Ollama 응답이 유효한 JSON이 아닙니다: {e}")


def create_script_prompt(topic: str) -> str:
    """
    대본 작성 프롬프트를 생성합니다.
    DeepSeek R1의 <think> 블록을 포함하도록 구성합니다.
    
    Args:
        topic: 비디오 주제
        
    Returns:
        완성된 프롬프트 텍스트
    """
    prompt = f"""<think>
사용자가 요청한 주제에 맞는 60초 이내 유튜브 쇼츠 대본을 작성해야 합니다.
주제: {topic}

요구사항을 분석하고, 각 장면의 대사와 이미지 프롬프트를 생성해야 합니다.
- 대사는 완전히 자연스러운 한국어 구어체로 작성해야 함
- 이미지 프롬프트는 최고 품질의 애니메 스타일을 생성하도록 구성해야 함
</think>

다음 주제에 맞는 60초 이내 유튜브 쇼츠 대본을 작성해주세요.

주제: {topic}

**대본 작성 요구사항 (매우 중요):**
1. 3-5개의 장면으로 구성 (각 장면 10-15초 분량)
2. 대사(script)는 **반드시 자연스러운 한국어 구어체**로 작성해야 합니다:
   - 일상 대화처럼 자연스럽고 부드러운 표현 사용
   - 어색하거나 딱딱한 문어체 표현 절대 금지
   - "~해요", "~입니다", "~네요" 같은 자연스러운 종결어미 사용
   - 오타나 띄어쓰기 오류 없이 완벽한 한국어로 작성
   - 감정이 자연스럽게 드러나는 표현
   - 시청자가 공감할 수 있는 친근한 톤
   - 예시 (좋음): "오늘은 마법학교 첫 수업 날이에요! 설레는 마음으로 학교에 도착했어요."
   - 예시 (나쁨): "등대에서 반짝이는 편지가 떨어져 내렸어요." (어색함)
3. 이미지 프롬프트(image_prompt)는 **최고 품질의 애니메 일러스트**를 생성하도록 작성:
   - 영어로 작성
   - **반드시 다음 고품질 태그로 시작**: "masterpiece, best quality, ultra detailed, anime style, consistent art style, JANKU style, detailed anime illustration, "
   - 구체적이고 시각적으로 매우 상세한 묘사
   - 캐릭터가 등장하는 경우: "cute anime character, consistent character design, beautiful detailed face, "
   - 배경과 분위기도 매우 상세하게 묘사
   - 색감, 조명, 분위기가 모든 장면에서 일관되게 유지
   - 예: "masterpiece, best quality, ultra detailed, anime style, consistent art style, JANKU style, detailed anime illustration, cute anime character, [구체적인 장면 묘사]"

**이미지 프롬프트 고품질 가이드:**
- 모든 이미지 프롬프트는 반드시 다음으로 시작:
  "masterpiece, best quality, ultra detailed, anime style, consistent art style, JANKU style, detailed anime illustration, "
- 캐릭터가 등장하는 경우 추가:
  "cute anime character, consistent character design, beautiful detailed face, expressive eyes, "
- 배경과 분위기도 매우 상세하게 묘사
- 색감과 조명도 구체적으로 표현

**중요**: 반드시 다음 JSON 형식으로만 출력하세요. 코드 블록 안에 JSON만 포함하세요:

```json
{{
  "scenes": [
    {{
      "script": "완전히 자연스러운 한국어 구어체로 작성된 첫 번째 장면의 대사",
      "image_prompt": "masterpiece, best quality, ultra detailed, anime style, consistent art style, JANKU style, detailed anime illustration, [구체적인 장면 묘사]"
    }},
    {{
      "script": "완전히 자연스러운 한국어 구어체로 작성된 두 번째 장면의 대사",
      "image_prompt": "masterpiece, best quality, ultra detailed, anime style, consistent art style, JANKU style, detailed anime illustration, [구체적인 장면 묘사]"
    }}
  ]
}}
```

JSON 코드 블록 안의 JSON만 출력하고, 다른 설명이나 텍스트는 포함하지 마세요."""
    
    return prompt


def generate_script(topic: str) -> List[Dict[str, str]]:
    """
    주제에 맞는 쇼츠 대본을 생성합니다.
    
    Args:
        topic: 비디오 주제
        
    Returns:
        장면 리스트: [{"script": str, "image_prompt": str, "audio_path": "", "image_path": ""}, ...]
        
    Raises:
        ValueError: 대본 생성 또는 파싱 실패 시
    """
    logger.info(f"[대본 작성] 주제: {topic}")
    
    try:
        # 프롬프트 생성
        prompt = create_script_prompt(topic)
        
        # Ollama 호출
        response_text = call_ollama(prompt)
        
        logger.info(f"[대본 작성] LLM 응답 수신 (길이: {len(response_text)} 문자)")
        
        # JSON 추출 및 파싱
        parsed_data = extract_json_from_text(response_text)
        
        if "scenes" not in parsed_data:
            raise ValueError("응답에 'scenes' 키가 없습니다.")
        
        scenes = parsed_data["scenes"]
        
        if not isinstance(scenes, list) or len(scenes) == 0:
            raise ValueError(f"scenes가 유효한 리스트가 아닙니다: {scenes}")
        
        # 각 장면에 초기 경로 필드 추가
        for scene in scenes:
            if not isinstance(scene, dict):
                raise ValueError(f"장면이 유효한 딕셔너리가 아닙니다: {scene}")
            
            scene.setdefault("script", "")
            scene.setdefault("image_prompt", "")
            scene.setdefault("audio_path", "")
            scene.setdefault("image_path", "")
        
        logger.info(f"[대본 작성] 완료: {len(scenes)}개 장면 생성")
        
        return scenes
        
    except Exception as e:
        logger.error(f"[대본 작성] 오류 발생: {e}", exc_info=True)
        raise


def node_script_writer(state: Dict) -> Dict:
    """
    LangGraph 노드 함수: 대본 작성
    
    Args:
        state: 현재 상태 딕셔너리
        
    Returns:
        업데이트된 상태 딕셔너리
    """
    try:
        topic = state.get("topic", "")
        if not topic:
            raise ValueError("상태에 'topic'이 없습니다.")
        
        scenes = generate_script(topic)
        
        # 대본을 주제별 폴더에 JSON 파일로 저장
        output_dir = Config.get_output_dir(topic=topic)
        script_path = output_dir / "script.json"
        
        script_data = {
            "topic": topic,
            "scenes": scenes
        }
        
        try:
            with open(script_path, 'w', encoding='utf-8') as f:
                json.dump(script_data, f, ensure_ascii=False, indent=2)
            logger.info(f"[대본 작성] 대본 저장 완료: {script_path}")
        except Exception as e:
            logger.warning(f"[대본 작성] 대본 저장 실패: {e}")
        
        return {
            **state,
            "scenes": scenes
        }
        
    except Exception as e:
        logger.error(f"[대본 작성 노드] 오류: {e}", exc_info=True)
        raise



================================================================================
File Path: .\agents\tts.py
================================================================================

"""
TTS (Text-to-Speech) 에이전트
edge-tts를 사용하여 텍스트를 오디오로 변환합니다.
"""

import asyncio
import logging
import os
from pathlib import Path
from typing import Dict, List

import edge_tts

from src.config import Config

logger = logging.getLogger(__name__)


async def generate_audio_async(script: str, output_path: str, voice: str = None) -> None:
    """
    edge-tts를 사용하여 텍스트를 오디오로 변환합니다 (비동기).
    
    Args:
        script: 변환할 텍스트
        output_path: 저장할 오디오 파일 경로
        voice: 사용할 음성 (기본값: Config.TTS_VOICE)
        
    Raises:
        Exception: 오디오 생성 실패 시
    """
    voice = voice or Config.TTS_VOICE
    
    if not script or not script.strip():
        raise ValueError("빈 스크립트는 오디오로 변환할 수 없습니다.")
    
    try:
        logger.debug(f"오디오 생성 시작: {output_path} (음성: {voice})")
        communicate = edge_tts.Communicate(script, voice)
        await communicate.save(output_path)
        
        # 파일 생성 확인
        if not os.path.exists(output_path):
            raise FileNotFoundError(f"오디오 파일이 생성되지 않았습니다: {output_path}")
        
        logger.debug(f"오디오 생성 완료: {output_path}")
        
    except Exception as e:
        logger.error(f"오디오 생성 실패 ({output_path}): {e}")
        raise


def generate_all_audios(scenes: List[Dict], output_dir: Path) -> List[Dict]:
    """
    모든 장면의 오디오를 생성합니다.
    
    Args:
        scenes: 장면 리스트
        output_dir: 출력 디렉토리
        
    Returns:
        오디오 경로가 업데이트된 장면 리스트
        
    Raises:
        ValueError: 스크립트가 없는 장면이 있는 경우
    """
    logger.info(f"[오디오 생성] {len(scenes)}개 장면 처리 시작")
    
    async def generate_all_async():
        tasks = []
        for idx, scene in enumerate(scenes):
            script = scene.get('script', '').strip()
            if not script:
                raise ValueError(f"장면 {idx+1}에 대사가 없습니다.")
            
            audio_path = output_dir / f"audio_scene_{idx+1}.mp3"
            tasks.append(generate_audio_async(script, str(audio_path)))
        
        # 모든 오디오 생성 작업 병렬 실행
        await asyncio.gather(*tasks)
    
    # 비동기 함수 실행
    try:
        asyncio.run(generate_all_async())
    except Exception as e:
        logger.error(f"[오디오 생성] 비동기 실행 실패: {e}", exc_info=True)
        raise
    
    # 생성된 오디오 경로를 상태에 업데이트
    updated_scenes = []
    for idx, scene in enumerate(scenes):
        audio_path = output_dir / f"audio_scene_{idx+1}.mp3"
        
        if not os.path.exists(audio_path):
            raise FileNotFoundError(f"오디오 파일이 생성되지 않았습니다: {audio_path}")
        
        scene['audio_path'] = str(audio_path)
        updated_scenes.append(scene)
        logger.info(f"[오디오 생성] 장면 {idx+1} 완료: {audio_path}")
    
    logger.info(f"[오디오 생성] 모든 오디오 생성 완료")
    
    return updated_scenes


def node_audio_generator(state: Dict) -> Dict:
    """
    LangGraph 노드 함수: 오디오 생성
    
    Args:
        state: 현재 상태 딕셔너리
        
    Returns:
        업데이트된 상태 딕셔너리
    """
    try:
        scenes = state.get("scenes", [])
        if not scenes:
            raise ValueError("상태에 'scenes'가 없거나 비어있습니다.")
        
        topic = state.get("topic", "")
        output_dir = Config.get_output_dir(topic=topic)
        updated_scenes = generate_all_audios(scenes, output_dir)
        
        return {
            **state,
            "scenes": updated_scenes
        }
        
    except Exception as e:
        logger.error(f"[오디오 생성 노드] 오류: {e}", exc_info=True)
        raise



================================================================================
File Path: .\agents\vision.py
================================================================================

"""
비전 에이전트 모듈
이미지 생성 관련 유틸리티 및 헬퍼 함수를 제공합니다.
"""

import logging
from typing import Dict

from src.tools.comfyui_client import node_visual_generator

logger = logging.getLogger(__name__)

# vision.py는 comfyui_client의 래퍼 역할을 합니다.
# 향후 확장 가능성을 위해 별도 모듈로 분리했습니다.

__all__ = ['node_visual_generator']



================================================================================
File Path: .\agents\__init__.py
================================================================================

"""에이전트 모듈"""



================================================================================
File Path: .\langgraph_automator.egg-info\dependency_links.txt
================================================================================




================================================================================
File Path: .\langgraph_automator.egg-info\requires.txt
================================================================================

edge-tts>=7.2.3
langchain-core>=1.1.0
langchain-ollama>=1.0.0
langgraph>=1.0.4
moviepy>=2.2.1
pillow>=10.0.0
pydantic>=2.12.5
requests>=2.32.5
websocket-client>=1.9.0


================================================================================
File Path: .\langgraph_automator.egg-info\SOURCES.txt
================================================================================

README.md
pyproject.toml
src/config.py
src/main.py
src/agents/__init__.py
src/agents/script_writer.py
src/agents/tts.py
src/agents/vision.py
src/langgraph_automator.egg-info/PKG-INFO
src/langgraph_automator.egg-info/SOURCES.txt
src/langgraph_automator.egg-info/dependency_links.txt
src/langgraph_automator.egg-info/requires.txt
src/langgraph_automator.egg-info/top_level.txt
src/tools/__init__.py
src/tools/comfyui_client.py
src/tools/video_editor.py
src/utils/__init__.py
src/utils/json_parser.py
src/utils/logger.py
src/workflow/__init__.py
src/workflow/graph.py

================================================================================
File Path: .\langgraph_automator.egg-info\top_level.txt
================================================================================

agents
config
main
tools
utils
workflow


================================================================================
File Path: .\tools\comfyui_client.py
================================================================================

"""
ComfyUI HTTP API 클라이언트 모듈

이 모듈은 ComfyUI 서버를 직접 실행하지 않고, HTTP API를 통해서만 통신합니다.
ComfyUI 서버는 사용자가 별도로 실행한 상태여야 하며,
COMFYUI_URL 환경변수에 지정된 HTTP 엔드포인트로만 요청을 보냅니다.

중요:
- ComfyUI 서버 프로세스는 이 코드에서 관리하지 않습니다
- 서버가 실행되지 않으면 명확한 에러 메시지를 표시합니다
- stderr/tqdm 충돌 문제를 피하기 위해 subprocess를 사용하지 않습니다
"""

import copy
import json
import logging
import os
import sys
import time
import uuid
from pathlib import Path
from typing import Dict, List, Optional

import requests
import websocket

from src.config import Config

logger = logging.getLogger(__name__)


class ComfyUIClient:
    """
    ComfyUI HTTP API 클라이언트
    
    이 클래스는 ComfyUI 서버를 직접 실행하지 않습니다.
    ComfyUI 서버는 사용자가 별도로 실행한 상태여야 하며,
    COMFYUI_URL 환경변수에 지정된 HTTP 엔드포인트로만 요청을 보냅니다.
    
    중요: ComfyUI 서버 프로세스는 이 코드에서 관리하지 않습니다.
    서버가 실행 중이지 않으면 명확한 에러 메시지를 표시합니다.
    """
    
    def __init__(self, base_url: str = None, ws_url: str = None, timeout: int = None):
        """
        ComfyUI 클라이언트 초기화
        
        서버는 외부에서 이미 실행 중이라고 가정합니다.
        서버를 직접 실행하거나 종료하지 않습니다.
        
        Args:
            base_url: ComfyUI 서버 URL (기본값: COMFYUI_URL 환경변수 또는 http://127.0.0.1:8188)
            ws_url: ComfyUI 웹소켓 URL (기본값: COMFYUI_WS_URL 환경변수 또는 ws://127.0.0.1:8188/ws)
            timeout: 타임아웃 (초, 기본값: COMFYUI_TIMEOUT 환경변수 또는 300)
        """
        # COMFYUI_URL 환경변수를 최우선으로 사용
        if base_url is None:
            base_url = os.getenv("COMFYUI_URL", "http://127.0.0.1:8188")
        if ws_url is None:
            ws_url = os.getenv("COMFYUI_WS_URL", "ws://127.0.0.1:8188/ws")
        if timeout is None:
            timeout = Config.COMFYUI_TIMEOUT
        
        # URL 정규화 (끝의 슬래시 제거)
        self.base_url = base_url.rstrip("/")
        self.ws_url = ws_url.rstrip("/")
        self.timeout = timeout
        self.client_id = str(uuid.uuid4())
        self.api_key = Config.COMFYUI_API_KEY if hasattr(Config, 'COMFYUI_API_KEY') else ""
        
        logger.debug(f"ComfyUI 클라이언트 초기화: {self.base_url} (서버는 외부에서 실행되어야 함)")
        
    def ping(self) -> bool:
        """
        ComfyUI 서버가 실행 중인지 확인합니다.
        
        서버는 외부에서 이미 실행되어야 합니다.
        이 메서드는 서버를 실행하지 않고, 단순히 헬스체크만 수행합니다.
        
        Returns:
            서버가 응답하면 True, 아니면 False
        """
        try:
            # system_stats 엔드포인트로 헬스체크
            url = f"{self.base_url}/system_stats"
            response = requests.get(url, timeout=5)
            return response.ok
        except Exception as e:
            logger.debug(f"ComfyUI 서버 헬스체크 실패: {e}")
            return False
    
    def check_health(self) -> None:
        """
        ComfyUI 서버 헬스체크를 수행하고, 실패 시 명확한 에러를 발생시킵니다.
        
        Raises:
            RuntimeError: 서버에 접속할 수 없는 경우
        """
        if not self.ping():
            raise RuntimeError(
                f"ComfyUI 서버({self.base_url})에 접속할 수 없습니다.\n"
                f"다음을 확인해주세요:\n"
                f"  1. ComfyUI 서버를 수동으로 실행했는지 확인\n"
                f"  2. .env 파일의 COMFYUI_URL 설정이 올바른지 확인 (현재: {self.base_url})\n"
                f"  3. ComfyUI 서버가 {self.base_url}에서 실행 중인지 확인"
            )
    
    def get_available_models(self) -> List[str]:
        """
        ComfyUI에서 사용 가능한 체크포인트 모델 목록을 가져옵니다.
        
        Returns:
            사용 가능한 모델 파일명 리스트
            
        Raises:
            requests.RequestException: API 호출 실패 시
        """
        try:
            url = f"{self.base_url}/object_info"
            response = requests.get(url, timeout=10)
            
            # 연결 실패 시 명확한 에러 메시지
            if response.status_code == 404:
                raise RuntimeError(
                    f"ComfyUI 서버({self.base_url})를 찾을 수 없습니다. "
                    "서버가 실행 중인지 확인해주세요."
                )
            
            response.raise_for_status()
            
            object_info = response.json()
            checkpoint_info = object_info.get("CheckpointLoaderSimple", {})
            input_info = checkpoint_info.get("input", {})
            required = input_info.get("required", {})
            ckpt_name_info = required.get("ckpt_name", [])
            
            if isinstance(ckpt_name_info, list) and len(ckpt_name_info) > 0:
                models = ckpt_name_info[0] if isinstance(ckpt_name_info[0], list) else ckpt_name_info
                logger.info(f"사용 가능한 모델 {len(models)}개 발견")
                return models
            else:
                logger.warning("사용 가능한 모델을 찾을 수 없습니다.")
                return []
                
        except requests.ConnectionError as e:
            error_msg = (
                f"ComfyUI 서버({self.base_url})에 연결할 수 없습니다.\n"
                f"서버를 수동으로 실행한 뒤 다시 시도해주세요.\n"
                f"연결 오류: {e}"
            )
            logger.error(error_msg)
            raise RuntimeError(error_msg) from e
        except requests.RequestException as e:
            logger.error(f"모델 목록 조회 실패: {e}")
            raise RuntimeError(
                f"ComfyUI API 호출 실패 ({self.base_url}): {e}\n"
                "서버가 실행 중이고 URL이 올바른지 확인해주세요."
            ) from e
    
    def get_available_node_types(self) -> List[str]:
        """
        ComfyUI에서 사용 가능한 노드 타입 목록을 가져옵니다.
        
        Returns:
            사용 가능한 노드 타입 리스트
        """
        try:
            url = f"{self.base_url}/object_info"
            response = requests.get(url, timeout=10)
            
            if not response.ok:
                if response.status_code == 404:
                    raise RuntimeError(
                        f"ComfyUI 서버({self.base_url})를 찾을 수 없습니다. "
                        "서버가 실행 중인지 확인해주세요."
                    )
                response.raise_for_status()
            
            object_info = response.json()
            node_types = list(object_info.keys())
            logger.debug(f"사용 가능한 노드 타입 {len(node_types)}개 발견")
            return node_types
                
        except requests.ConnectionError as e:
            error_msg = (
                f"ComfyUI 서버({self.base_url})에 연결할 수 없습니다.\n"
                f"서버를 수동으로 실행한 뒤 다시 시도해주세요."
            )
            logger.error(error_msg)
            raise RuntimeError(error_msg) from e
        except requests.RequestException as e:
            logger.error(f"노드 타입 목록 조회 실패: {e}")
            raise RuntimeError(
                f"ComfyUI API 호출 실패 ({self.base_url}): {e}\n"
                "서버가 실행 중이고 URL이 올바른지 확인해주세요."
            ) from e
    
    def check_node_exists(self, node_type: str) -> bool:
        """
        특정 노드 타입이 ComfyUI에 존재하는지 확인합니다.
        
        Args:
            node_type: 확인할 노드 타입 이름
            
        Returns:
            노드가 존재하면 True, 아니면 False
        """
        available_nodes = self.get_available_node_types()
        exists = node_type in available_nodes
        if not exists:
            # I2V 관련 노드 찾기
            i2v_nodes = [n for n in available_nodes if 'i2v' in n.lower() or 'imagetovideo' in n.lower() or 'video' in n.lower()]
            if i2v_nodes:
                logger.warning(
                    f"노드 '{node_type}'를 찾을 수 없습니다. "
                    f"사용 가능한 I2V 관련 노드: {', '.join(i2v_nodes[:5])}"
                )
            else:
                logger.warning(f"노드 '{node_type}'를 찾을 수 없습니다.")
        return exists
    
    def load_workflow(self, workflow_path: str = None) -> Dict:
        """
        ComfyUI 워크플로우 JSON 파일을 로드하고 모델을 자동으로 설정합니다.
        
        Args:
            workflow_path: 워크플로우 JSON 파일 경로
            
        Returns:
            워크플로우 딕셔너리
        """
        workflow_path = workflow_path or Config.COMFYUI_WORKFLOW_PATH
        
        if not os.path.exists(workflow_path):
            logger.warning(f"워크플로우 파일이 없어 기본 워크플로우를 생성합니다: {workflow_path}")
            default_workflow = self._create_default_workflow()
            
            with open(workflow_path, 'w', encoding='utf-8') as f:
                json.dump(default_workflow, f, indent=2, ensure_ascii=False)
            
            workflow = default_workflow
        else:
            try:
                with open(workflow_path, 'r', encoding='utf-8') as f:
                    workflow = json.load(f)
                logger.debug(f"워크플로우 로드 완료: {workflow_path}")
            except Exception as e:
                logger.error(f"워크플로우 로드 실패: {e}")
                raise
        
        # CheckpointLoaderSimple 또는 UNETLoader 노드 찾아서 모델 자동 설정
        checkpoint_node_id = None
        unet_node_id = None
        
        for node_id, node_data in workflow.items():
            class_type = node_data.get("class_type")
            if class_type == "CheckpointLoaderSimple":
                checkpoint_node_id = node_id
            elif class_type == "UNETLoader":
                unet_node_id = node_id
        
        # CheckpointLoaderSimple이 있으면 기존 방식 사용
        if checkpoint_node_id:
            # 환경 변수에서 지정된 모델이 있으면 우선 사용
            if Config.COMFYUI_CHECKPOINT:
                workflow[checkpoint_node_id]["inputs"]["ckpt_name"] = Config.COMFYUI_CHECKPOINT
                logger.info(f"환경 변수에서 지정된 모델 사용: {Config.COMFYUI_CHECKPOINT}")
            else:
                # 사용 가능한 모델 목록 가져오기
                available_models = self.get_available_models()
                
                if available_models:
                    # 첫 번째 모델 사용
                    selected_model = available_models[0]
                    workflow[checkpoint_node_id]["inputs"]["ckpt_name"] = selected_model
                    logger.info(f"모델 자동 선택: {selected_model}")
                else:
                    # 모델이 없으면 기본값 유지하되 경고
                    current_model = workflow[checkpoint_node_id]["inputs"].get("ckpt_name", "")
                    if current_model:
                        logger.warning(f"사용 가능한 모델을 찾을 수 없습니다. 기본 모델 사용: {current_model}")
                    else:
                        logger.error("사용 가능한 모델이 없고 기본 모델도 설정되지 않았습니다.")
        
        # UNETLoader가 있으면 Wan2.2 방식 사용
        if unet_node_id:
            # 환경 변수에서 지정된 UNet 모델이 있으면 사용 (I2V_UNET_NAME)
            if hasattr(Config, 'I2V_UNET_NAME') and Config.I2V_UNET_NAME:
                workflow[unet_node_id]["inputs"]["unet_name"] = Config.I2V_UNET_NAME
                logger.info(f"환경 변수에서 지정된 UNet 모델 사용: {Config.I2V_UNET_NAME}")
            else:
                # 기본값 유지
                current_unet = workflow[unet_node_id]["inputs"].get("unet_name", "")
                if current_unet:
                    logger.info(f"UNet 모델 사용: {current_unet}")
                else:
                    logger.warning("UNet 모델이 설정되지 않았습니다.")
        
        return workflow
    
    def _create_default_workflow(self) -> Dict:
        """기본 워크플로우 생성"""
        return {
            "1": {
                "inputs": {
                    "text": "default prompt",
                    "clip": ["4", 1]
                },
                "class_type": "CLIPTextEncode",
                "_meta": {"title": "CLIP Text Encode (Prompt)"}
            },
            "2": {
                "inputs": {
                    "text": "",
                    "clip": ["4", 1]
                },
                "class_type": "CLIPTextEncode",
                "_meta": {"title": "CLIP Text Encode (Negative)"}
            },
            "3": {
                "inputs": {
                    "width": 1024,
                    "height": 1024,
                    "batch_size": 1
                },
                "class_type": "EmptyLatentImage",
                "_meta": {"title": "Empty Latent Image"}
            },
            "4": {
                "inputs": {
                    "ckpt_name": Config.COMFYUI_CHECKPOINT or "v1-5-pruned-emaonly.safetensors"
                },
                "class_type": "CheckpointLoaderSimple",
                "_meta": {"title": "Load Checkpoint"}
            },
            "5": {
                "inputs": {
                    "seed": 12345,
                    "steps": 20,
                    "cfg": 7,
                    "sampler_name": "euler",
                    "scheduler": "normal",
                    "denoise": 1,
                    "model": ["4", 0],
                    "positive": ["1", 0],
                    "negative": ["2", 0],
                    "latent_image": ["3", 0]
                },
                "class_type": "KSampler",
                "_meta": {"title": "KSampler"}
            },
            "6": {
                "inputs": {
                    "samples": ["5", 0],
                    "vae": ["4", 2]
                },
                "class_type": "VAEDecode",
                "_meta": {"title": "VAE Decode"}
            },
            "7": {
                "inputs": {
                    "filename_prefix": "ComfyUI",
                    "images": ["6", 0]
                },
                "class_type": "SaveImage",
                "_meta": {"title": "Save Image"}
            }
        }
    
    def update_prompt(self, workflow: Dict, prompt: str, ensure_style_consistency: bool = True) -> Dict:
        """
        워크플로우에서 프롬프트 노드를 찾아 프롬프트를 업데이트합니다.
        딥카피를 사용하여 원본 워크플로우를 보호합니다.
        
        Args:
            workflow: ComfyUI 워크플로우 딕셔너리
            prompt: 새로운 프롬프트
            ensure_style_consistency: 스타일 일관성 태그 자동 추가 여부 (기본값: True)
            
        Returns:
            업데이트된 워크플로우 (딥카피)
        """
        if not prompt or not prompt.strip():
            raise ValueError("프롬프트가 비어있습니다.")
        
        # 딥카피 생성
        updated_workflow = copy.deepcopy(workflow)
        
        # 고품질 스타일 태그 추가 (이미 포함되어 있지 않은 경우)
        enhanced_prompt = prompt
        if ensure_style_consistency:
            # 고품질 태그 우선 확인
            quality_tags = ["masterpiece", "best quality", "ultra detailed"]
            style_tags = ["anime style", "consistent art style", "JANKU style", "detailed anime illustration"]
            
            prompt_lower = prompt.lower()
            
            # 고품질 태그가 없으면 추가
            missing_quality_tags = [tag for tag in quality_tags if tag.lower() not in prompt_lower]
            missing_style_tags = [tag for tag in style_tags if tag.lower() not in prompt_lower]
            
            if missing_quality_tags or missing_style_tags:
                all_missing_tags = missing_quality_tags + missing_style_tags
                enhanced_prompt = ", ".join(all_missing_tags) + ", " + prompt
                logger.debug(f"고품질 스타일 태그 추가: {', '.join(all_missing_tags)}")
        
        # CLIPTextEncode 노드 찾기
        # positive 프롬프트는 보통 빈 문자열이 아니거나 긴 텍스트를 가짐
        prompt_node_id = None
        
        for node_id, node_data in updated_workflow.items():
            if node_data.get("class_type") == "CLIPTextEncode":
                inputs = node_data.get("inputs", {})
                if "text" in inputs:
                    current_text = inputs.get("text", "")
                    # negative 프롬프트가 아닌 경우 (비어있지 않거나 긴 경우)
                    # 또는 _meta에 "Prompt"가 포함된 경우
                    meta_title = node_data.get("_meta", {}).get("title", "")
                    if "Prompt" in meta_title and "Negative" not in meta_title:
                        prompt_node_id = node_id
                        break
                    elif current_text and current_text != "" and len(current_text) > 10:
                        prompt_node_id = node_id
                        break
        
        if not prompt_node_id:
            # 첫 번째 CLIPTextEncode 노드를 사용
            for node_id, node_data in updated_workflow.items():
                if node_data.get("class_type") == "CLIPTextEncode":
                    prompt_node_id = node_id
                    break
        
        if not prompt_node_id:
            raise ValueError("워크플로우에서 CLIPTextEncode 노드를 찾을 수 없습니다.")
        
        updated_workflow[prompt_node_id]["inputs"]["text"] = enhanced_prompt
        logger.debug(f"프롬프트 업데이트: 노드 {prompt_node_id} - {enhanced_prompt[:80]}...")
        
        return updated_workflow
    
    def _save_prompt_to_file(self, prompt_id: str, workflow: Dict) -> Path:
        """
        프롬프트 워크플로우를 파일로 저장합니다 (디버깅용).
        
        Args:
            prompt_id: 프롬프트 ID
            workflow: 워크플로우 딕셔너리
            
        Returns:
            저장된 파일 경로
        """
        logs_dir = Path("logs") / "comfyui_prompts"
        logs_dir.mkdir(parents=True, exist_ok=True)
        
        prompt_file = logs_dir / f"{prompt_id}.json"
        try:
            with open(prompt_file, 'w', encoding='utf-8') as f:
                json.dump(workflow, f, indent=2, ensure_ascii=False)
            logger.debug(f"프롬프트 워크플로우 저장: {prompt_file}")
            return prompt_file
        except Exception as e:
            logger.warning(f"프롬프트 워크플로우 저장 실패: {e}")
            return prompt_file
    
    def _save_history_to_file(self, prompt_id: str, history_data: Dict) -> Path:
        """
        ComfyUI history 응답을 파일로 저장합니다 (디버깅용).
        
        Args:
            prompt_id: 프롬프트 ID
            history_data: history 딕셔너리 (전체 또는 prompt_id에 해당하는 부분)
            
        Returns:
            저장된 파일 경로
        """
        logs_dir = Path("logs") / "comfyui_history"
        logs_dir.mkdir(parents=True, exist_ok=True)
        
        history_file = logs_dir / f"{prompt_id}.json"
        try:
            with open(history_file, 'w', encoding='utf-8') as f:
                json.dump(history_data, f, indent=2, ensure_ascii=False)
            logger.debug(f"ComfyUI history 저장: {history_file}")
            return history_file
        except Exception as e:
            logger.warning(f"ComfyUI history 저장 실패: {e}")
            return history_file
    
    def _extract_error_details(self, error_data: Dict, prompt_data: Dict = None) -> Dict:
        """
        ComfyUI 에러 데이터에서 상세 정보를 추출합니다.
        
        Args:
            error_data: execution_error 메시지의 데이터 부분
            prompt_data: 프롬프트 전체 데이터 (inputs 추출용)
            
        Returns:
            에러 상세 정보 딕셔너리
        """
        details = {
            "node_id": error_data.get("node_id", ""),
            "node_type": error_data.get("node_type", ""),
            "exception_type": error_data.get("exception_type", ""),
            "exception_message": error_data.get("exception_message", ""),
            "traceback": error_data.get("traceback", []),
            "current_inputs": error_data.get("current_inputs", {}),
            "current_outputs": error_data.get("current_outputs", []),
        }
        
        # KSampler인 경우 주요 입력값 추출
        if details["node_type"] == "KSampler" and prompt_data:
            prompt = prompt_data.get("prompt", {})
            node_id = details["node_id"]
            if node_id in prompt:
                node_config = prompt[node_id]
                if isinstance(node_config, dict):
                    inputs = node_config.get("inputs", {})
                    details["ksampler_inputs"] = {
                        "seed": inputs.get("seed"),
                        "steps": inputs.get("steps"),
                        "cfg": inputs.get("cfg"),
                        "sampler_name": inputs.get("sampler_name"),
                        "scheduler": inputs.get("scheduler"),
                        "denoise": inputs.get("denoise"),
                    }
        
        return details
    
    def execute_prompt(self, workflow: Dict, retry_count: int = None) -> str:
        """
        ComfyUI에 프롬프트를 실행 요청합니다.
        
        Args:
            workflow: 실행할 워크플로우
            retry_count: 재시도 횟수 (기본값: Config.COMFYUI_RETRY_COUNT)
            
        Returns:
            프롬프트 ID
            
        Raises:
            requests.RequestException: API 호출 실패 시
        """
        retry_count = retry_count or Config.COMFYUI_RETRY_COUNT
        
        prompt_payload = {
            "prompt": workflow,
            "client_id": self.client_id
        }
        
        url = f"{self.base_url}/prompt"
        
        # API 키가 있으면 헤더에 추가
        headers = {}
        if self.api_key:
            headers["Authorization"] = f"Bearer {self.api_key}"
            logger.debug("ComfyUI API 키를 헤더에 추가했습니다.")
        
        last_error = None
        for attempt in range(retry_count + 1):
            try:
                logger.debug(f"ComfyUI 프롬프트 실행 요청 (시도 {attempt + 1}/{retry_count + 1})")
                response = requests.post(url, json=prompt_payload, headers=headers, timeout=10)
                
                # 연결 실패 시 명확한 에러 메시지
                if isinstance(response, requests.ConnectionError) or (hasattr(response, 'status_code') and response.status_code == 0):
                    raise RuntimeError(
                        f"ComfyUI 서버({self.base_url})에 연결할 수 없습니다.\n"
                        f"서버를 수동으로 실행한 뒤 다시 시도해주세요."
                    )
                
                # 400 오류인 경우 상세 정보 로깅
                if response.status_code == 400:
                    try:
                        error_detail = response.json()
                        logger.error(f"ComfyUI 400 오류 상세: {json.dumps(error_detail, indent=2, ensure_ascii=False)}")
                    except:
                        logger.error(f"ComfyUI 400 오류 응답 본문: {response.text[:500]}")
                
                # 404 오류인 경우 서버 미실행으로 간주
                if response.status_code == 404:
                    raise RuntimeError(
                        f"ComfyUI 서버({self.base_url})를 찾을 수 없습니다.\n"
                        f"서버가 실행 중인지 확인해주세요."
                    )
                
                response.raise_for_status()
                
                result = response.json()
                prompt_id = result.get("prompt_id")
                
                if not prompt_id:
                    raise ValueError("ComfyUI에서 prompt_id를 받지 못했습니다.")
                
                # 프롬프트 워크플로우를 파일로 저장 (디버깅용)
                prompt_file = self._save_prompt_to_file(prompt_id, workflow)
                logger.debug(f"프롬프트 워크플로우 저장됨: {prompt_file}")
                
                logger.info(f"프롬프트 ID: {prompt_id}")
                return prompt_id
                
            except requests.ConnectionError as e:
                last_error = RuntimeError(
                    f"ComfyUI 서버({self.base_url})에 연결할 수 없습니다.\n"
                    f"서버를 수동으로 실행한 뒤 다시 시도해주세요.\n"
                    f"연결 오류: {e}"
                )
                if attempt < retry_count:
                    wait_time = (attempt + 1) * 2  # 지수 백오프
                    logger.warning(f"ComfyUI 서버 연결 실패 (시도 {attempt + 1}/{retry_count + 1}), {wait_time}초 후 재시도")
                    time.sleep(wait_time)
                else:
                    logger.error(f"ComfyUI 서버 연결 최종 실패")
            except requests.RequestException as e:
                last_error = e
                if attempt < retry_count:
                    wait_time = (attempt + 1) * 2  # 지수 백오프
                    logger.warning(f"ComfyUI API 호출 실패 (시도 {attempt + 1}/{retry_count + 1}), {wait_time}초 후 재시도: {e}")
                    time.sleep(wait_time)
                else:
                    logger.error(f"ComfyUI API 호출 최종 실패: {e}")
        
        if last_error:
            raise last_error
        else:
            raise RuntimeError("ComfyUI 프롬프트 실행 실패: 알 수 없는 오류")
    
    def _is_fatal_error(self, error_data: Dict) -> bool:
        """
        에러가 치명적인지(재시도 불가능한지) 판단합니다.
        
        Args:
            error_data: execution_error 메시지의 데이터 부분
            
        Returns:
            치명적 에러면 True, 아니면 False
        """
        exception_type = error_data.get("exception_type", "")
        exception_message = str(error_data.get("exception_message", ""))
        
        # OSError [Errno 22] Invalid argument는 치명적 에러
        if exception_type == "OSError" and "[Errno 22] Invalid argument" in exception_message:
            return True
        
        # 다른 치명적 에러 타입도 여기에 추가 가능
        # 예: ValueError, TypeError 등 입력값 문제
        
        return False
    
    def _get_history_images(self, prompt_id: str, max_retries: int = 10, retry_delay: int = 3) -> List[str]:
        """
        ComfyUI API를 통해 히스토리에서 이미지 파일명을 조회합니다.
        이미지 생성 완료를 기다리기 위해 여러 번 재시도합니다.
        
        치명적 에러(OSError Errno 22 등)가 발생하면 재시도하지 않고 즉시 예외를 발생시킵니다.
        
        Args:
            prompt_id: 프롬프트 ID
            max_retries: 최대 재시도 횟수
            retry_delay: 재시도 간 대기 시간 (초)
            
        Returns:
            생성된 이미지 파일명 리스트
            
        Raises:
            RuntimeError: 치명적 에러 발생 시 또는 최대 재시도 도달 시
        """
        logger.info(f"히스토리 API로 이미지 조회 시작 (프롬프트 ID: {prompt_id}, 최대 {max_retries}회 시도)")
        
        for attempt in range(max_retries):
            try:
                # ComfyUI 히스토리 API는 전체 히스토리를 반환
                url = f"{self.base_url}/history"
                logger.debug(f"히스토리 API 호출: {url} (시도 {attempt + 1}/{max_retries})")
                response = requests.get(url, timeout=10)
                
                # 연결 실패 시 명확한 에러 메시지
                if response.status_code == 404:
                    raise RuntimeError(
                        f"ComfyUI 서버({self.base_url})를 찾을 수 없습니다. "
                        "서버가 실행 중인지 확인해주세요."
                    )
                
                response.raise_for_status()
                
                history = response.json()
                
                # 히스토리 전체를 파일로 저장 (디버깅용, 첫 번째 시도에서만)
                if attempt == 0 and prompt_id in history:
                    history_file = self._save_history_to_file(prompt_id, history)
                    logger.debug(f"ComfyUI history 저장됨: {history_file}")
                
                images = []
                
                # 히스토리 구조 확인
                if not isinstance(history, dict):
                    logger.warning(f"히스토리 응답이 딕셔너리가 아닙니다: {type(history)}")
                    if attempt < max_retries - 1:
                        time.sleep(retry_delay)
                        continue
                    else:
                        return []
                
                # 히스토리에서 해당 prompt_id 찾기
                if prompt_id in history:
                    prompt_data = history[prompt_id]
                    outputs = prompt_data.get("outputs", {})
                    status = prompt_data.get("status", {})
                    prompt_workflow = prompt_data.get("prompt", {})
                    
                    # 상태 확인 (실행 실패 여부)
                    error_detected = False
                    error_msg = None
                    error_details = None
                    is_fatal = False
                    
                    # status가 딕셔너리인 경우 messages 배열 확인
                    if isinstance(status, dict):
                        status_str = status.get("status_str", "")
                        completed = status.get("completed", True)
                        messages = status.get("messages", [])
                        
                        # messages 배열에서 execution_error 찾기
                        for msg in messages:
                            if isinstance(msg, list) and len(msg) > 0:
                                msg_type = msg[0]
                                if msg_type == "execution_error" and len(msg) > 1:
                                    error_data = msg[1] if isinstance(msg[1], dict) else {}
                                    
                                    # 에러 상세 정보 추출
                                    error_details = self._extract_error_details(error_data, prompt_data)
                                    
                                    # 치명적 에러인지 확인
                                    is_fatal = self._is_fatal_error(error_data)
                                    
                                    # DEBUG: 에러 노드 전체 데이터 출력
                                    logger.debug(f"[에러 상세] 프롬프트 ID {prompt_id}, 노드 {error_details['node_id']} ({error_details['node_type']}):")
                                    logger.debug(f"  - exception_type: {error_details['exception_type']}")
                                    logger.debug(f"  - exception_message: {error_details['exception_message']}")
                                    logger.debug(f"  - current_inputs: {json.dumps(error_details['current_inputs'], indent=2, ensure_ascii=False)[:2000]}")
                                    if error_details.get('ksampler_inputs'):
                                        logger.debug(f"  - ksampler_inputs: {json.dumps(error_details['ksampler_inputs'], indent=2, ensure_ascii=False)}")
                                    if error_details.get('traceback'):
                                        logger.debug(f"  - traceback (최근 5줄): {error_details['traceback'][-5:]}")
                                    
                                    # WARNING/ERROR: 핵심 정보만 출력
                                    error_msg = (
                                        f"ComfyUI 실행 실패\n"
                                        f"  프롬프트 ID: {prompt_id}\n"
                                        f"  노드 ID: {error_details['node_id']}\n"
                                        f"  노드 타입: {error_details['node_type']}\n"
                                        f"  예외 타입: {error_details['exception_type']}\n"
                                        f"  예외 메시지: {error_details['exception_message']}"
                                    )
                                    
                                    # KSampler인 경우 주요 입력값 추가
                                    if error_details.get('ksampler_inputs'):
                                        ksampler = error_details['ksampler_inputs']
                                        error_msg += (
                                            f"\n  KSampler 입력값:\n"
                                            f"    seed: {ksampler.get('seed')}\n"
                                            f"    steps: {ksampler.get('steps')}\n"
                                            f"    cfg: {ksampler.get('cfg')}\n"
                                            f"    sampler_name: {ksampler.get('sampler_name')}\n"
                                            f"    scheduler: {ksampler.get('scheduler')}\n"
                                            f"    denoise: {ksampler.get('denoise')}"
                                        )
                                    
                                    # 치명적 에러인 경우 추가 안내
                                    if is_fatal:
                                        error_msg += (
                                            f"\n\n[중요] 이 에러는 치명적 에러로, 같은 프롬프트로 재시도해도 해결되지 않습니다.\n"
                                            f"ComfyUI 서버 측 문제일 수도 있지만, 현재 프롬프트나 노드 설정이 잘못되었을 가능성이 높습니다.\n"
                                            f"에러 로그에 출력된 노드 입력값(seed, steps, cfg 등)을 먼저 확인해보세요.\n"
                                            f"이 에러가 발생한 프롬프트 전체 내용은 logs/comfyui_prompts/{prompt_id}.json에 저장되어 있습니다."
                                        )
                                    else:
                                        error_msg += (
                                            f"\n\n[해결 방법] 이 에러는 ComfyUI 서버 측 문제일 수 있습니다. 다음을 시도해보세요:\n"
                                            f"  1. ComfyUI 서버를 재시작하세요\n"
                                            f"  2. ComfyUI-Manager 커스텀 노드를 업데이트하세요\n"
                                            f"  3. ComfyUI 서버 로그를 확인하세요"
                                        )
                                    
                                    error_detected = True
                                    break
                        
                        # messages에 없으면 status_str 확인
                        if not error_detected and (not completed or "error" in status_str.lower() or "failed" in status_str.lower()):
                            error_msg = f"ComfyUI 실행 실패: {status_str}"
                            error_detected = True
                    
                    # status가 리스트인 경우 (이전 형식)
                    elif isinstance(status, list) and len(status) > 0:
                        status_info = status[0] if isinstance(status[0], dict) else status
                        if isinstance(status_info, dict):
                            status_str = status_info.get("status_str", "")
                            completed = status_info.get("completed", True)
                            if not completed or "error" in status_str.lower() or "failed" in status_str.lower():
                                # 에러 메시지 추출
                                exception_message = status_info.get("exception_message", "")
                                exception_type = status_info.get("exception_type", "")
                                node_id = status_info.get("node_id", "")
                                node_type = status_info.get("node_type", "")
                                
                                error_data = {
                                    "node_id": node_id,
                                    "node_type": node_type,
                                    "exception_type": exception_type,
                                    "exception_message": exception_message,
                                }
                                
                                error_details = self._extract_error_details(error_data, prompt_data)
                                is_fatal = self._is_fatal_error(error_data)
                                
                                error_msg = (
                                    f"ComfyUI 실행 실패\n"
                                    f"  프롬프트 ID: {prompt_id}\n"
                                    f"  노드 ID: {node_id}\n"
                                    f"  노드 타입: {node_type}\n"
                                    f"  예외 타입: {exception_type}\n"
                                    f"  예외 메시지: {exception_message}"
                                )
                                
                                if is_fatal:
                                    error_msg += (
                                        f"\n\n[중요] 이 에러는 치명적 에러로, 같은 프롬프트로 재시도해도 해결되지 않습니다.\n"
                                        f"이 에러가 발생한 프롬프트 전체 내용은 logs/comfyui_prompts/{prompt_id}.json에 저장되어 있습니다."
                                    )
                                
                                error_detected = True
                    
                    # 에러 노드의 outputs 전체를 DEBUG 로그로 덤프
                    if error_detected and outputs:
                        logger.debug(f"[에러 노드 출력] 프롬프트 ID {prompt_id}의 outputs 구조:")
                        for node_id, node_output in outputs.items():
                            if isinstance(node_output, dict):
                                logger.debug(f"  노드 {node_id}: {json.dumps(node_output, indent=2, ensure_ascii=False)[:2000]}")
                    
                    # 히스토리 전체를 DEBUG 로그로 출력 (에러 발생 시)
                    if error_detected:
                        logger.debug(f"[ComfyUI History 전체] 프롬프트 ID {prompt_id}:")
                        logger.debug(json.dumps(prompt_data, indent=2, ensure_ascii=False)[:5000])
                    
                    if error_detected and error_msg:
                        logger.error(f"프롬프트 ID {prompt_id} {error_msg}")
                        
                        # 치명적 에러는 즉시 예외 발생 (재시도하지 않음)
                        if is_fatal:
                            raise RuntimeError(error_msg)
                        
                        # 치명적이지 않은 에러는 재시도 가능
                        if attempt < max_retries - 1:
                            logger.warning(f"에러 발생, {retry_delay}초 후 재시도... (시도 {attempt + 1}/{max_retries})")
                            time.sleep(retry_delay)
                            continue
                        else:
                            # 최대 재시도 도달 시 예외 발생
                            raise RuntimeError(error_msg)
                    
                    logger.info(f"히스토리에서 프롬프트 ID {prompt_id} 발견, 출력 노드 수: {len(outputs)}, 상태: {status}")
                    
                    # outputs 구조 상세 로깅
                    if outputs:
                        logger.debug(f"출력 노드 ID 목록: {list(outputs.keys())}")
                        for node_id, node_output in outputs.items():
                            logger.debug(f"노드 {node_id} 출력 구조: {list(node_output.keys()) if isinstance(node_output, dict) else type(node_output)}")
                            
                            # images 필드 확인
                            if isinstance(node_output, dict) and "images" in node_output:
                                images_list = node_output["images"]
                                logger.debug(f"노드 {node_id}의 이미지 리스트 타입: {type(images_list)}, 길이: {len(images_list) if isinstance(images_list, list) else 'N/A'}")
                                
                                if isinstance(images_list, list):
                                    for img_info in images_list:
                                        if isinstance(img_info, dict):
                                            filename = img_info.get("filename")
                                            if filename:
                                                images.append(filename)
                                                logger.info(f"히스토리에서 이미지 발견: {filename} (노드 {node_id})")
                                        elif isinstance(img_info, str):
                                            # 이미지 정보가 문자열로 직접 들어올 수도 있음
                                            images.append(img_info)
                                            logger.info(f"히스토리에서 이미지 발견: {img_info} (노드 {node_id})")
                            elif isinstance(node_output, dict):
                                # 다른 필드에서 이미지 찾기 시도
                                for key, value in node_output.items():
                                    if "image" in key.lower() and isinstance(value, list):
                                        for item in value:
                                            if isinstance(item, dict) and "filename" in item:
                                                filename = item.get("filename")
                                                if filename:
                                                    images.append(filename)
                                                    logger.info(f"히스토리에서 이미지 발견 (키: {key}): {filename} (노드 {node_id})")
                
                if images:
                    logger.info(f"히스토리 API에서 {len(images)}개 이미지 발견 (시도 {attempt + 1}/{max_retries})")
                    return images
                else:
                    if prompt_id in history:
                        prompt_data = history[prompt_id]
                        outputs = prompt_data.get("outputs", {})
                        status = prompt_data.get("status", {})
                        
                        # 상태에서 에러 확인 (이미 위에서 처리했지만, 재확인)
                        has_error = False
                        if isinstance(status, list) and len(status) > 0:
                            for status_item in status:
                                if isinstance(status_item, list) and len(status_item) > 1:
                                    status_type = status_item[0]
                                    status_data = status_item[1] if isinstance(status_item[1], dict) else {}
                                    if status_type == "execution_error":
                                        has_error = True
                                        break
                        
                        if has_error:
                            # 에러가 있으면 위에서 이미 예외가 발생했을 것이므로, 여기서는 로깅만
                            logger.warning(
                                f"프롬프트 ID {prompt_id}는 에러로 인해 이미지가 생성되지 않았습니다. "
                                f"출력 구조: {list(prompt_data.keys())}, "
                                f"출력 노드 수: {len(outputs)}"
                            )
                        else:
                            logger.warning(
                                f"프롬프트 ID {prompt_id}는 히스토리에 있지만 이미지가 없습니다. "
                                f"출력 구조: {list(prompt_data.keys())}, "
                                f"출력 노드 수: {len(outputs)}, "
                                f"상태: {status}"
                            )
                        # outputs 구조를 JSON으로 로깅 (디버깅용)
                        if outputs:
                            logger.debug(f"출력 상세 구조: {json.dumps(outputs, indent=2, ensure_ascii=False)[:2000]}")
                    else:
                        # 히스토리 키 목록 확인
                        history_keys = list(history.keys())
                        logger.info(f"히스토리에 {len(history_keys)}개 항목이 있습니다. 프롬프트 ID {prompt_id}를 찾는 중...")
                        if history_keys:
                            logger.debug(f"히스토리 키 목록 (최대 5개): {history_keys[:5]}")
                            # 유사한 ID 찾기
                            similar_ids = [k for k in history_keys if prompt_id[:8] in k or k[:8] in prompt_id]
                            if similar_ids:
                                logger.debug(f"유사한 프롬프트 ID 발견: {similar_ids[:3]}")
                    
                    if attempt < max_retries - 1:
                        logger.info(f"히스토리에서 이미지를 찾지 못했습니다. {retry_delay}초 후 재시도... (시도 {attempt + 1}/{max_retries})")
                        time.sleep(retry_delay)
                    else:
                        logger.error(f"히스토리에서 프롬프트 ID {prompt_id}를 찾을 수 없거나 이미지가 없습니다 (최대 재시도 횟수 도달)")
                
            except requests.ConnectionError as e:
                error_msg = (
                    f"ComfyUI 서버({self.base_url})에 연결할 수 없습니다.\n"
                    f"서버를 수동으로 실행한 뒤 다시 시도해주세요."
                )
                if attempt < max_retries - 1:
                    logger.warning(f"히스토리 API 연결 실패, {retry_delay}초 후 재시도 (시도 {attempt + 1}/{max_retries}): {e}")
                    time.sleep(retry_delay)
                else:
                    logger.error(error_msg)
                    raise RuntimeError(error_msg) from e
            except requests.RequestException as e:
                if attempt < max_retries - 1:
                    logger.warning(f"히스토리 API 조회 실패, {retry_delay}초 후 재시도 (시도 {attempt + 1}/{max_retries}): {e}")
                    time.sleep(retry_delay)
                else:
                    logger.error(f"히스토리 API 조회 최종 실패: {e}")
                    raise RuntimeError(
                        f"ComfyUI 히스토리 API 호출 실패 ({self.base_url}): {e}\n"
                        "서버가 실행 중이고 URL이 올바른지 확인해주세요."
                    ) from e
            except Exception as e:
                logger.error(f"히스토리 API 조회 중 예상치 못한 오류: {e}", exc_info=True)
                if attempt < max_retries - 1:
                    time.sleep(retry_delay)
        
        logger.error(f"히스토리 API로 이미지를 찾지 못했습니다 (프롬프트 ID: {prompt_id})")
        return []
    
    def wait_for_completion(self, prompt_id: str, timeout: int = None, use_websocket: bool = False) -> List[str]:
        """
        ComfyUI 이미지 생성 완료를 대기합니다.
        기본적으로 히스토리 API를 사용하며, use_websocket=True 시 웹소켓을 먼저 시도합니다.
        
        Args:
            prompt_id: 프롬프트 ID
            timeout: 타임아웃 (초, 기본값: self.timeout)
            use_websocket: 웹소켓 사용 여부 (기본값: False)
            
        Returns:
            생성된 이미지 파일명 리스트
            
        Raises:
            TimeoutError: 타임아웃 발생 시
            ValueError: 이미지가 생성되지 않은 경우
        """
        timeout = timeout or self.timeout
        start_time = time.time()
        images = []
        
        # 웹소켓 사용 시 먼저 시도
        if use_websocket:
            images = self._wait_via_websocket(prompt_id, timeout)
        
        # 웹소켓에서 이미지를 받지 못했으면 히스토리 API 사용
        if not images:
            logger.info(f"히스토리 API로 이미지 조회 중... (프롬프트 ID: {prompt_id})")
            images = self._get_history_images(prompt_id, max_retries=10, retry_delay=3)
        
        # 타임아웃 체크
        elapsed_time = time.time() - start_time
        if elapsed_time > timeout:
            raise TimeoutError(f"ComfyUI 이미지 생성 타임아웃 ({timeout}초)")
        
        if not images:
            raise ValueError(f"이미지가 생성되지 않았습니다. 프롬프트 ID: {prompt_id}")
        
        logger.info(f"이미지 생성 완료: {len(images)}개 파일")
        return images
    
    def _wait_via_websocket(self, prompt_id: str, timeout: int) -> List[str]:
        """
        웹소켓을 통해 이미지 생성 완료를 대기합니다.
        
        Args:
            prompt_id: 프롬프트 ID
            timeout: 타임아웃 (초)
            
        Returns:
            생성된 이미지 파일명 리스트 (실패 시 빈 리스트)
        """
        ws_url = f"{self.ws_url}?clientId={self.client_id}"
        
        images = []
        completed = False
        execution_error = None
        
        def on_message(ws, message):
            nonlocal images, completed, execution_error
            try:
                if isinstance(message, str):
                    data = json.loads(message)
                    message_type = data.get("type")
                    
                    logger.debug(f"웹소켓 메시지 수신: type={message_type}")
                    
                    if message_type == "executed":
                        exec_data = data.get("data", {})
                        exec_prompt_id = exec_data.get("prompt_id")
                        
                        if exec_prompt_id == prompt_id:
                            if "error" in exec_data:
                                execution_error = exec_data.get("error")
                                logger.error(f"ComfyUI 실행 에러: {execution_error}")
                                completed = True
                                ws.close()
                                return
                            
                            output = exec_data.get("output", {})
                            for node_id, node_output in output.items():
                                if "images" in node_output:
                                    for img_info in node_output["images"]:
                                        filename = img_info.get("filename")
                                        if filename:
                                            images.append(filename)
                            
                            completed = True
                            ws.close()
                            
                    elif message_type == "progress":
                        progress_data = data.get("data", {})
                        progress = progress_data.get("value", 0)
                        max_progress = progress_data.get("max", 0)
                        if max_progress > 0:
                            logger.debug(f"ComfyUI 진행률: {progress}/{max_progress}")
                        
            except Exception as e:
                logger.error(f"웹소켓 메시지 처리 오류: {e}")
        
        def on_error(ws, error):
            logger.debug(f"ComfyUI 웹소켓 오류: {error}")
        
        def on_close(ws, close_status_code, close_msg):
            logger.debug(f"ComfyUI 웹소켓 연결 종료")
        
        def on_open(ws):
            logger.debug("ComfyUI 웹소켓 연결 성공")
        
        try:
            logger.debug(f"웹소켓 연결 시도: {ws_url}")
            ws = websocket.WebSocketApp(
                ws_url,
                on_message=on_message,
                on_error=on_error,
                on_close=on_close,
                on_open=on_open
            )
            ws.run_forever(ping_interval=30, ping_timeout=10)
            
        except Exception as e:
            logger.debug(f"웹소켓 연결 실패: {e}")
        
        if execution_error:
            raise RuntimeError(f"ComfyUI 실행 에러: {execution_error}")
        
        return images
    
    def download_result(self, filename: str, output_path: str) -> None:
        """
        ComfyUI에서 생성된 이미지를 다운로드합니다.
        
        Args:
            filename: 이미지 파일명
            output_path: 저장할 경로
            
        Raises:
            requests.RequestException: 다운로드 실패 시
        """
        image_url = f"{self.base_url}/view?filename={filename}&subfolder=&type=output"
        
        try:
            logger.debug(f"이미지 다운로드 시작: {filename}")
            response = requests.get(image_url, timeout=30)
            
            # 연결 실패 시 명확한 에러 메시지
            if response.status_code == 404:
                raise RuntimeError(
                    f"ComfyUI 서버({self.base_url})에서 이미지를 찾을 수 없습니다.\n"
                    f"이미지 파일명: {filename}\n"
                    "서버가 실행 중이고 이미지가 생성되었는지 확인해주세요."
                )
            
            response.raise_for_status()
            
            with open(output_path, 'wb') as f:
                f.write(response.content)
            
            if not os.path.exists(output_path):
                raise FileNotFoundError(f"다운로드된 파일이 없습니다: {output_path}")
            
            logger.info(f"이미지 다운로드 완료: {output_path}")
            
        except requests.ConnectionError as e:
            error_msg = (
                f"ComfyUI 서버({self.base_url})에 연결할 수 없습니다.\n"
                f"서버를 수동으로 실행한 뒤 다시 시도해주세요.\n"
                f"이미지 파일명: {filename}"
            )
            logger.error(error_msg)
            raise RuntimeError(error_msg) from e
        except requests.RequestException as e:
            logger.error(f"이미지 다운로드 실패 ({filename}): {e}")
            raise RuntimeError(
                f"이미지 다운로드 실패 ({self.base_url}): {e}\n"
                f"이미지 파일명: {filename}\n"
                "서버가 실행 중이고 이미지가 생성되었는지 확인해주세요."
            ) from e


def generate_images(scenes: List[Dict], output_dir: Path, retry_count: int = None) -> List[Dict]:
    """
    모든 장면의 이미지를 생성합니다.
    
    Args:
        scenes: 장면 리스트
        output_dir: 출력 디렉토리
        retry_count: 재시도 횟수
        
    Returns:
        이미지 경로가 업데이트된 장면 리스트
    """
    # 모의 모드 체크
    if Config.COMFYUI_USE_MOCK:
        from src.tools.comfyui_mock import generate_images_mock
        return generate_images_mock(scenes, output_dir)
    
    logger.info(f"[이미지 생성] {len(scenes)}개 장면 처리 시작")
    
    # ComfyUI 클라이언트 초기화 (서버는 외부에서 실행되어야 함)
    client = ComfyUIClient()
    
    # 서버 헬스체크 (선택적, 첫 번째 시도에서만)
    try:
        client.check_health()
        logger.debug("ComfyUI 서버 헬스체크 통과")
    except RuntimeError as e:
        logger.error(f"ComfyUI 서버 헬스체크 실패: {e}")
        raise
    
    workflow = client.load_workflow()
    
    updated_scenes = []
    retry_count = retry_count or Config.COMFYUI_RETRY_COUNT
    
    for idx, scene in enumerate(scenes):
        image_prompt = scene.get('image_prompt', '').strip()
        if not image_prompt:
            raise ValueError(f"장면 {idx+1}에 이미지 프롬프트가 없습니다.")
        
        logger.info(f"[이미지 생성] 장면 {idx+1} 처리 중: {image_prompt[:50]}...")
        
        # 워크플로우 프롬프트 업데이트
        updated_workflow = client.update_prompt(workflow, image_prompt)
        
        # 이미지 생성 (재시도 포함)
        last_error = None
        for attempt in range(retry_count + 1):
            try:
                # 프롬프트 실행 (매 재시도마다 새로운 prompt_id를 받음)
                prompt_id = client.execute_prompt(updated_workflow, retry_count=0)  # execute_prompt 내부에서 재시도
                
                # 완료 대기 (치명적 에러는 내부에서 즉시 예외 발생)
                image_filenames = client.wait_for_completion(prompt_id)
                
                if not image_filenames:
                    raise ValueError(f"장면 {idx+1}의 이미지가 생성되지 않았습니다.")
                
                # 첫 번째 이미지 다운로드
                image_filename = image_filenames[0]
                image_path = output_dir / f"image_scene_{idx+1}.png"
                client.download_result(image_filename, str(image_path))
                
                scene['image_path'] = str(image_path)
                updated_scenes.append(scene)
                logger.info(f"[이미지 생성] 장면 {idx+1} 완료: {image_path}")
                break
                
            except RuntimeError as e:
                # 서버 연결 실패 등 명확한 에러는 즉시 재시도하지 않고 상위로 전파
                error_msg = str(e)
                if "접속할 수 없습니다" in error_msg or "연결할 수 없습니다" in error_msg:
                    logger.error(f"ComfyUI 서버 연결 실패 (장면 {idx+1}): {e}")
                    raise
                
                # 치명적 에러인 경우 (OSError Errno 22 등) 재시도하지 않음
                if "치명적 에러" in error_msg or "[Errno 22]" in error_msg:
                    logger.error(f"치명적 에러 발생 (장면 {idx+1}): {e}")
                    raise
                
                last_error = e
                if attempt < retry_count:
                    wait_time = (attempt + 1) * 3
                    logger.warning(f"이미지 생성 실패 (장면 {idx+1}, 시도 {attempt + 1}/{retry_count + 1}), {wait_time}초 후 재시도: {e}")
                    time.sleep(wait_time)
                else:
                    logger.error(f"이미지 생성 최종 실패 (장면 {idx+1}): {e}")
                    raise
            except Exception as e:
                last_error = e
                if attempt < retry_count:
                    wait_time = (attempt + 1) * 3
                    logger.warning(f"이미지 생성 실패 (장면 {idx+1}, 시도 {attempt + 1}/{retry_count + 1}), {wait_time}초 후 재시도: {e}")
                    time.sleep(wait_time)
                else:
                    logger.error(f"이미지 생성 최종 실패 (장면 {idx+1}): {e}")
                    raise
    
    logger.info(f"[이미지 생성] 모든 이미지 생성 완료")
    return updated_scenes


def node_visual_generator(state: Dict) -> Dict:
    """
    LangGraph 노드 함수: 이미지 생성
    
    Args:
        state: 현재 상태 딕셔너리
        
    Returns:
        업데이트된 상태 딕셔너리
    """
    try:
        scenes = state.get("scenes", [])
        if not scenes:
            raise ValueError("상태에 'scenes'가 없거나 비어있습니다.")
        
        topic = state.get("topic", "")
        output_dir = Config.get_output_dir(topic=topic)
        updated_scenes = generate_images(scenes, output_dir)
        
        return {
            **state,
            "scenes": updated_scenes
        }
        
    except RuntimeError as e:
        # 서버 연결 실패 등 명확한 에러는 사용자 친화적 메시지로 전달
        error_msg = str(e)
        if "접속할 수 없습니다" in error_msg or "연결할 수 없습니다" in error_msg:
            logger.error(f"[이미지 생성 노드] ComfyUI 서버 연결 실패: {e}")
            raise RuntimeError(
                f"ComfyUI 서버에 연결할 수 없습니다.\n"
                f"서버를 수동으로 실행한 뒤 다시 시도해주세요.\n"
                f"상세: {error_msg}"
            ) from e
        raise
    except Exception as e:
        logger.error(f"[이미지 생성 노드] 오류: {e}", exc_info=True)
        raise


# ============================================================================
# CLI 엔트리 포인트 (단일 프롬프트 테스트용)
# ============================================================================

def main_cli():
    """
    단일 프롬프트 테스트용 CLI 엔트리 포인트
    
    사용법:
        python -m src.tools.comfyui_client --prompt "test girl, anime, 4k" --out test.png
    """
    import argparse
    
    parser = argparse.ArgumentParser(
        description="ComfyUI 클라이언트 테스트 도구 (단일 프롬프트 실행)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
예시:
  python -m src.tools.comfyui_client --prompt "test girl, anime, 4k" --out test.png
  python -m src.tools.comfyui_client --prompt "landscape" --out output.png --workflow custom_workflow.json
        """
    )
    parser.add_argument(
        "--prompt", "-p",
        type=str,
        required=True,
        help="이미지 생성 프롬프트"
    )
    parser.add_argument(
        "--out", "-o",
        type=str,
        default="test_output.png",
        help="출력 이미지 파일 경로 (기본값: test_output.png)"
    )
    parser.add_argument(
        "--workflow", "-w",
        type=str,
        default=None,
        help="워크플로우 JSON 파일 경로 (기본값: COMFYUI_WORKFLOW_PATH 환경변수 또는 comfyui_workflow.json)"
    )
    parser.add_argument(
        "--timeout", "-t",
        type=int,
        default=None,
        help="타임아웃 (초, 기본값: COMFYUI_TIMEOUT 환경변수 또는 300)"
    )
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="상세 로그 출력"
    )
    
    args = parser.parse_args()
    
    # 로깅 레벨 설정
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    else:
        logging.getLogger().setLevel(logging.INFO)
    
    try:
        # ComfyUI 클라이언트 초기화
        client = ComfyUIClient()
        
        # 헬스체크
        print(f"ComfyUI 서버 연결 확인 중... ({client.base_url})")
        client.check_health()
        print("✓ ComfyUI 서버 연결 성공")
        
        # 워크플로우 로드
        workflow_path = args.workflow or Config.COMFYUI_WORKFLOW_PATH
        print(f"워크플로우 로드 중... ({workflow_path})")
        workflow = client.load_workflow(workflow_path)
        print("✓ 워크플로우 로드 완료")
        
        # 프롬프트 업데이트
        print(f"프롬프트 업데이트 중... ({args.prompt[:50]}...)")
        updated_workflow = client.update_prompt(workflow, args.prompt)
        print("✓ 프롬프트 업데이트 완료")
        
        # 프롬프트 실행
        print("ComfyUI에 프롬프트 실행 요청 중...")
        prompt_id = client.execute_prompt(updated_workflow)
        print(f"✓ 프롬프트 실행됨 (ID: {prompt_id})")
        print(f"  프롬프트 워크플로우 저장됨: logs/comfyui_prompts/{prompt_id}.json")
        
        # 완료 대기
        timeout = args.timeout or Config.COMFYUI_TIMEOUT
        print(f"이미지 생성 완료 대기 중... (타임아웃: {timeout}초)")
        image_filenames = client.wait_for_completion(prompt_id, timeout=timeout)
        print(f"✓ 이미지 생성 완료 ({len(image_filenames)}개 파일)")
        
        # 이미지 다운로드
        output_path = Path(args.out)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        print(f"이미지 다운로드 중... ({image_filenames[0]})")
        client.download_result(image_filenames[0], str(output_path))
        print(f"✓ 이미지 다운로드 완료: {output_path}")
        
        print("\n" + "=" * 60)
        print("성공!")
        print("=" * 60)
        print(f"출력 파일: {output_path.absolute()}")
        print(f"프롬프트 ID: {prompt_id}")
        print(f"프롬프트 워크플로우: logs/comfyui_prompts/{prompt_id}.json")
        if Path(f"logs/comfyui_history/{prompt_id}.json").exists():
            print(f"ComfyUI History: logs/comfyui_history/{prompt_id}.json")
        
        return 0
        
    except KeyboardInterrupt:
        print("\n사용자에 의해 중단되었습니다.")
        return 130
        
    except Exception as e:
        print(f"\n오류 발생: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == "__main__":
    sys.exit(main_cli())



================================================================================
File Path: .\tools\comfyui_mock.py
================================================================================

"""
ComfyUI 모의(Mock) 모듈
ComfyUI 서버 없이 테스트하기 위한 더미 이미지 생성 기능
"""

import logging
from pathlib import Path
from typing import Dict, List
from PIL import Image, ImageDraw, ImageFont
import numpy as np

from src.config import Config

logger = logging.getLogger(__name__)


def generate_mock_image(image_prompt: str, output_path: Path, width: int = 1024, height: int = 1024) -> None:
    """
    더미 이미지를 생성합니다 (ComfyUI 없이 테스트용).
    
    Args:
        image_prompt: 이미지 프롬프트 (텍스트로 표시)
        output_path: 저장할 경로
        width: 이미지 너비
        height: 이미지 높이
    """
    # 그라데이션 배경 생성
    img = Image.new('RGB', (width, height), color='#2C3E50')
    draw = ImageDraw.Draw(img)
    
    # 그라데이션 효과
    for y in range(height):
        r = int(44 + (y / height) * 20)  # 44-64
        g = int(62 + (y / height) * 30)  # 62-92
        b = int(80 + (y / height) * 40)  # 80-120
        draw.line([(0, y), (width, y)], fill=(r, g, b))
    
    # 프롬프트 텍스트 추가
    try:
        # 시스템 폰트 사용 시도
        font = ImageFont.truetype("arial.ttf", 40)
    except:
        try:
            font = ImageFont.truetype("C:/Windows/Fonts/arial.ttf", 40)
        except:
            font = ImageFont.load_default()
    
    # 텍스트를 여러 줄로 나누기
    words = image_prompt.split()
    lines = []
    current_line = ""
    
    for word in words:
        test_line = current_line + (" " if current_line else "") + word
        bbox = draw.textbbox((0, 0), test_line, font=font)
        text_width = bbox[2] - bbox[0]
        
        if text_width < width - 100:
            current_line = test_line
        else:
            if current_line:
                lines.append(current_line)
            current_line = word
    
    if current_line:
        lines.append(current_line)
    
    # 텍스트 그리기
    text_y = height // 2 - (len(lines) * 50) // 2
    for line in lines:
        bbox = draw.textbbox((0, 0), line, font=font)
        text_width = bbox[2] - bbox[0]
        text_x = (width - text_width) // 2
        
        # 텍스트 그림자
        draw.text((text_x + 2, text_y + 2), line, font=font, fill='#000000')
        # 텍스트
        draw.text((text_x, text_y), line, font=font, fill='#FFFFFF')
        text_y += 50
    
    # "MOCK IMAGE" 라벨 추가
    label = "MOCK IMAGE (ComfyUI not available)"
    try:
        label_font = ImageFont.truetype("arial.ttf", 20)
    except:
        try:
            label_font = ImageFont.truetype("C:/Windows/Fonts/arial.ttf", 20)
        except:
            label_font = ImageFont.load_default()
    
    label_bbox = draw.textbbox((0, 0), label, font=label_font)
    label_width = label_bbox[2] - label_bbox[0]
    label_x = (width - label_width) // 2
    draw.text((label_x, height - 40), label, font=label_font, fill='#FFA500')
    
    # 이미지 저장
    img.save(output_path, 'PNG')
    logger.info(f"더미 이미지 생성 완료: {output_path}")


def generate_images_mock(scenes: List[Dict], output_dir: Path) -> List[Dict]:
    """
    모든 장면의 더미 이미지를 생성합니다 (ComfyUI 없이 테스트용).
    
    Args:
        scenes: 장면 리스트
        output_dir: 출력 디렉토리
        
    Returns:
        이미지 경로가 업데이트된 장면 리스트
    """
    logger.warning("[이미지 생성] ComfyUI 모의 모드: 더미 이미지 생성 중...")
    logger.warning("[이미지 생성] 실제 ComfyUI 서버를 사용하려면 COMFYUI_USE_MOCK=false로 설정하세요.")
    
    updated_scenes = []
    
    for idx, scene in enumerate(scenes):
        image_prompt = scene.get('image_prompt', '').strip()
        if not image_prompt:
            raise ValueError(f"장면 {idx+1}에 이미지 프롬프트가 없습니다.")
        
        logger.info(f"[이미지 생성] 장면 {idx+1} 더미 이미지 생성 중: {image_prompt[:50]}...")
        
        image_path = output_dir / f"image_scene_{idx+1}.png"
        generate_mock_image(image_prompt, image_path)
        
        scene['image_path'] = str(image_path)
        updated_scenes.append(scene)
        logger.info(f"[이미지 생성] 장면 {idx+1} 완료: {image_path}")
    
    logger.info(f"[이미지 생성] 모든 더미 이미지 생성 완료")
    return updated_scenes



================================================================================
File Path: .\tools\motion_gen.py
================================================================================

"""
Wan2.2 I2V 모션 생성 모듈

ComfyUI의 Wan2.2 Distill I2V 모델을 사용하여 정적 이미지를 애니메이션 프레임 시퀀스로 변환합니다.

중요:
- ComfyUI 서버는 외부에서 이미 실행되어야 합니다
- 이 모듈은 HTTP API만 사용하며, 서버 프로세스를 관리하지 않습니다
- ComfyUIClient를 내부적으로 사용하여 HTTP 요청을 보냅니다
"""

import json
import logging
import os
import random
from pathlib import Path
from typing import Dict, List, Optional, Tuple

import requests
from PIL import Image

from src.config import Config
from src.tools.comfyui_client import ComfyUIClient

logger = logging.getLogger(__name__)


class MotionGenerator:
    """Wan2.2 I2V를 사용한 모션 생성 클래스"""
    
    def __init__(self, client: Optional[ComfyUIClient] = None):
        """
        모션 생성기 초기화
        
        ComfyUI 서버는 외부에서 이미 실행되어야 합니다.
        이 클래스는 서버를 실행하지 않고 HTTP API만 사용합니다.
        
        Args:
            client: ComfyUI 클라이언트 (None이면 새로 생성)
        """
        self.client = client or ComfyUIClient()
        
        # 서버 헬스체크 (선택적)
        try:
            self.client.check_health()
            logger.debug("ComfyUI 서버 헬스체크 통과 (모션 생성)")
        except RuntimeError as e:
            logger.warning(f"ComfyUI 서버 헬스체크 실패 (모션 생성): {e}")
            # 헬스체크 실패해도 계속 진행 (실제 API 호출 시 에러 발생)
        self.motion_fps = Config.MOTION_FPS
        self.motion_duration = Config.MOTION_DURATION
        self.frames_per_scene = int(self.motion_fps * self.motion_duration)
        self.i2v_steps = Config.I2V_STEPS
        self.i2v_guidance = Config.I2V_GUIDANCE
        self.i2v_node_type = Config.I2V_NODE_TYPE
        self.i2v_clip_name = Config.I2V_CLIP_NAME
        self.i2v_vae_name = Config.I2V_VAE_NAME
        self.i2v_unet_name = Config.I2V_UNET_NAME
        self.i2v_model_sampling_shift = Config.I2V_MODEL_SAMPLING_SHIFT
    
    def _get_image_dimensions(self, image_path: str) -> Tuple[int, int]:
        """
        이미지의 해상도를 가져옵니다.
        
        Args:
            image_path: 이미지 파일 경로
            
        Returns:
            (width, height) 튜플
        """
        try:
            with Image.open(image_path) as img:
                return img.size
        except Exception as e:
            logger.warning(f"이미지 해상도 감지 실패, 기본값 사용: {e}")
            return (1024, 1024)  # 기본 해상도
    
    def create_wan2_i2v_workflow(self, image_filename: str, prompt: str, width: int, height: int, seed: int = None) -> Dict:
        """
        Wan2.2 I2V 워크플로우를 생성합니다.
        JSON 파일의 구조를 기반으로 올바른 워크플로우를 생성합니다.
        
        Args:
            image_filename: 입력 이미지 파일명 (ComfyUI에서 접근 가능한 이름)
            prompt: 모션 프롬프트
            width: 이미지 너비
            height: 이미지 높이
            seed: 시드값 (None이면 랜덤)
            
        Returns:
            Wan2.2 I2V 워크플로우 딕셔너리
        """
        if seed is None:
            seed = random.randint(0, 2**32 - 1)
        
        # 프레임 개수 계산 (length는 프레임 수)
        length = self.frames_per_scene
        
        # Negative prompt (기본값)
        negative_prompt = "色调艳丽，过曝，静态，细节模糊不清，字幕，风格，作品，画作，画面，静止，整体发灰，最差质量，低质量，JPEG压缩残留，丑陋的，残缺的，多余的手指，画得不好的手部，画得不好的脸部，畸形的，毁容的，形态畸形的肢体，手指融合，静止不动的画面，杂乱的背景，三条腿，背景人很多，倒着走"
        
        # Wan2.2 I2V 워크플로우 구조 (JSON 기반):
        # 1. LoadImage - 입력 이미지 로드
        # 2. CLIPLoader - CLIP 텍스트 인코더 로드
        # 3. CLIPTextEncode - 프롬프트 인코딩 (positive, negative)
        # 4. VAELoader - VAE 로드
        # 5. UNETLoader - UNet 모델 로드 (high_noise)
        # 6. ModelSamplingSD3 - 모델 샘플링 설정
        # 7. WanImageToVideo - I2V 변환 (CONDITIONING, LATENT 출력)
        # 8. KSamplerAdvanced - 샘플링
        # 9. VAEDecode - 디코딩
        # 10. SaveImage - 프레임 저장
        
        workflow = {
            "1": {
                "inputs": {
                    "image": image_filename
                },
                "class_type": "LoadImage",
                "_meta": {"title": "Load Image"}
            },
            "2": {
                "inputs": {
                    "clip_name": self.i2v_clip_name,
                    "type": "wan",
                    "device": "default"
                },
                "class_type": "CLIPLoader",
                "_meta": {"title": "Load CLIP"}
            },
            "3": {
                "inputs": {
                    "clip": ["2", 0],
                    "text": prompt
                },
                "class_type": "CLIPTextEncode",
                "_meta": {"title": "CLIP Text Encode (Positive Prompt)"}
            },
            "4": {
                "inputs": {
                    "clip": ["2", 0],
                    "text": negative_prompt
                },
                "class_type": "CLIPTextEncode",
                "_meta": {"title": "CLIP Text Encode (Negative Prompt)"}
            },
            "5": {
                "inputs": {
                    "vae_name": self.i2v_vae_name
                },
                "class_type": "VAELoader",
                "_meta": {"title": "Load VAE"}
            },
            "6": {
                "inputs": {
                    "unet_name": self.i2v_unet_name,
                    "weight_dtype": "default"
                },
                "class_type": "UNETLoader",
                "_meta": {"title": "Load UNet (High Noise)"}
            },
            "7": {
                "inputs": {
                    "model": ["6", 0],
                    "shift": self.i2v_model_sampling_shift
                },
                "class_type": "ModelSamplingSD3",
                "_meta": {"title": "Model Sampling SD3"}
            },
            "8": {
                "inputs": {
                    "positive": ["3", 0],
                    "negative": ["4", 0],
                    "vae": ["5", 0],
                    "clip_vision_output": None,
                    "start_image": ["1", 0],
                    "width": width,
                    "height": height,
                    "length": length,
                    "batch_size": 1
                },
                "class_type": "WanImageToVideo",
                "_meta": {"title": "Wan Image to Video"}
            },
            "9": {
                "inputs": {
                    "model": ["7", 0],
                    "positive": ["8", 0],
                    "negative": ["8", 1],
                    "latent_image": ["8", 2],
                    "add_noise": "enable",
                    "noise_seed": seed,
                    "steps": self.i2v_steps,
                    "cfg": self.i2v_guidance,
                    "sampler_name": "euler",
                    "scheduler": "simple",
                    "start_at_step": 0,
                    "end_at_step": 10,
                    "return_with_leftover_noise": "enable"
                },
                "class_type": "KSamplerAdvanced",
                "_meta": {"title": "KSampler Advanced"}
            },
            "10": {
                "inputs": {
                    "samples": ["9", 0],
                    "vae": ["5", 0]
                },
                "class_type": "VAEDecode",
                "_meta": {"title": "VAE Decode"}
            },
            "11": {
                "inputs": {
                    "filename_prefix": "wan2_i2v",
                    "images": ["10", 0]
                },
                "class_type": "SaveImage",
                "_meta": {"title": "Save Image Frames"}
            }
        }
        
        return workflow
    
    def _upload_image(self, image_path: str) -> str:
        """
        이미지를 ComfyUI에 업로드합니다.
        
        Args:
            image_path: 업로드할 이미지 파일 경로
            
        Returns:
            업로드된 이미지 파일명
        """
        if not os.path.exists(image_path):
            raise FileNotFoundError(f"이미지 파일이 없습니다: {image_path}")
        
        upload_url = f"{self.client.base_url}/upload/image"
        
        try:
            with open(image_path, 'rb') as f:
                files = {'image': (os.path.basename(image_path), f, 'image/png')}
                response = requests.post(upload_url, files=files, timeout=60)
                
                # 연결 실패 시 명확한 에러 메시지
                if response.status_code == 404:
                    raise RuntimeError(
                        f"ComfyUI 서버({self.client.base_url})를 찾을 수 없습니다.\n"
                        "서버가 실행 중인지 확인해주세요."
                    )
                
                response.raise_for_status()
                
                result = response.json()
                # ComfyUI는 보통 {"name": "filename.png"} 형식으로 반환
                uploaded_filename = result.get("name") or os.path.basename(image_path)
                logger.info(f"[모션 생성] 이미지 업로드 완료: {uploaded_filename}")
                return uploaded_filename
                
        except requests.ConnectionError as e:
            error_msg = (
                f"ComfyUI 서버({self.client.base_url})에 연결할 수 없습니다.\n"
                f"서버를 수동으로 실행한 뒤 다시 시도해주세요.\n"
                f"이미지 파일: {image_path}"
            )
            logger.error(f"[모션 생성] 이미지 업로드 실패: {error_msg}")
            raise RuntimeError(error_msg) from e
        except requests.RequestException as e:
            error_msg = (
                f"이미지 업로드 실패 ({self.client.base_url}): {e}\n"
                f"이미지 파일: {image_path}\n"
                "서버가 실행 중이고 URL이 올바른지 확인해주세요."
            )
            logger.error(f"[모션 생성] {error_msg}")
            raise RuntimeError(error_msg) from e
        except Exception as e:
            logger.error(f"[모션 생성] 이미지 업로드 실패: {e}")
            raise RuntimeError(
                f"이미지 업로드 중 예상치 못한 오류: {e}\n"
                f"이미지 파일: {image_path}"
            ) from e
    
    def generate_motion_frames(self, image_path: str, prompt: str, output_dir: Path, scene_index: int) -> List[str]:
        """
        정적 이미지를 애니메이션 프레임 시퀀스로 변환합니다.
        
        Args:
            image_path: 입력 이미지 파일 경로
            prompt: 모션 프롬프트 (Wan2.2 I2V는 프롬프트를 사용하지 않지만 호환성을 위해 유지)
            output_dir: 출력 디렉토리
            scene_index: 장면 인덱스
            
        Returns:
            생성된 프레임 파일 경로 리스트
        """
        logger.info(f"[모션 생성] 장면 {scene_index + 1} 시작: {image_path}")
        
        # 프레임 저장 디렉토리 생성
        frames_dir = output_dir / "motion" / f"scene_{scene_index + 1}"
        frames_dir.mkdir(parents=True, exist_ok=True)
        
        try:
            # 이미지 해상도 감지
            width, height = self._get_image_dimensions(image_path)
            logger.info(f"[모션 생성] 이미지 해상도: {width}x{height}")
            
            # 이미지 업로드 (ComfyUI가 접근할 수 있도록)
            image_filename = self._upload_image(image_path)
            
            # I2V 노드 존재 확인
            if not self.client.check_node_exists(self.i2v_node_type):
                raise ValueError(
                    f"I2V 노드 '{self.i2v_node_type}'가 ComfyUI에 설치되지 않았습니다. "
                    f"환경 변수 I2V_NODE_TYPE을 실제 노드 이름으로 설정하거나, "
                    f"ComfyUI에 해당 노드를 설치해주세요."
                )
            
            # Wan2.2 I2V 워크플로우 생성
            seed = random.randint(0, 2**32 - 1)
            workflow = self.create_wan2_i2v_workflow(image_filename, prompt, width, height, seed)
            
            logger.info(
                f"[모션 생성] Wan2.2 I2V 워크플로우 생성 완료 "
                f"(노드: {self.i2v_node_type}, 시드: {seed}, 프레임: {self.frames_per_scene}, "
                f"스텝: {self.i2v_steps}, Guidance: {self.i2v_guidance})"
            )
            logger.debug(f"[모션 생성] 워크플로우 노드 수: {len(workflow)}")
            logger.debug(f"[모션 생성] 워크플로우 JSON: {json.dumps(workflow, indent=2, ensure_ascii=False)}")
            
            # ComfyUI에 프롬프트 실행
            prompt_id = self.client.execute_prompt(workflow, retry_count=0)
            logger.info(f"[모션 생성] 프롬프트 실행됨 (ID: {prompt_id})")
            
            # 완료 대기 및 프레임 다운로드
            image_filenames = self.client.wait_for_completion(prompt_id)
            
            if not image_filenames:
                raise ValueError(f"장면 {scene_index + 1}의 모션 프레임이 생성되지 않았습니다.")
            
            logger.info(f"[모션 생성] {len(image_filenames)}개 프레임 생성됨")
            
            # 예상 프레임 개수 검증
            expected_frames = self.frames_per_scene
            if len(image_filenames) != expected_frames:
                logger.warning(
                    f"[모션 생성] 프레임 개수 불일치: "
                    f"예상 {expected_frames}개, 실제 {len(image_filenames)}개"
                )
            
            # 프레임 다운로드 및 저장
            frame_paths = []
            for idx, filename in enumerate(image_filenames):
                frame_path = frames_dir / f"frame_{idx:04d}.png"
                try:
                    self.client.download_result(filename, str(frame_path))
                    frame_paths.append(str(frame_path))
                    logger.debug(f"[모션 생성] 프레임 {idx + 1}/{len(image_filenames)} 다운로드 완료")
                except Exception as e:
                    logger.warning(f"[모션 생성] 프레임 {idx + 1} 다운로드 실패: {e}")
            
            if not frame_paths:
                raise ValueError(f"장면 {scene_index + 1}의 프레임을 다운로드할 수 없습니다.")
            
            # 최종 프레임 개수 검증
            logger.info(
                f"[모션 생성] 장면 {scene_index + 1} 완료: "
                f"{len(frame_paths)}개 프레임 저장됨 "
                f"(예상: {expected_frames}개, FPS: {self.motion_fps}, "
                f"길이: {self.motion_duration}초)"
            )
            
            return frame_paths
            
        except Exception as e:
            logger.error(f"[모션 생성] 장면 {scene_index + 1} 실패: {e}", exc_info=True)
            raise
    
    def generate_all_motions(self, scenes: List[Dict], output_dir: Path) -> List[Dict]:
        """
        모든 장면의 모션 프레임을 생성합니다.
        
        Args:
            scenes: 장면 리스트 (image_path 포함)
            output_dir: 출력 디렉토리
            
        Returns:
            motion_frames_path가 추가된 장면 리스트
        """
        logger.info(f"[모션 생성] {len(scenes)}개 장면의 모션 생성 시작 (Wan2.2 I2V)")
        logger.info(
            f"[모션 생성] 설정: FPS={self.motion_fps}, "
            f"길이={self.motion_duration}초, "
            f"프레임/장면={self.frames_per_scene}, "
            f"스텝={self.i2v_steps}, Guidance={self.i2v_guidance}"
        )
        
        updated_scenes = []
        
        for idx, scene in enumerate(scenes):
            image_path = scene.get('image_path', '')
            image_prompt = scene.get('image_prompt', '')
            
            if not image_path:
                raise ValueError(f"장면 {idx+1}에 이미지 경로가 없습니다.")
            
            if not os.path.exists(image_path):
                raise FileNotFoundError(f"이미지 파일이 없습니다: {image_path}")
            
            # 모션 프레임 생성
            frame_paths = self.generate_motion_frames(
                image_path=image_path,
                prompt=image_prompt,
                output_dir=output_dir,
                scene_index=idx
            )
            
            # 프레임 개수 최종 검증
            if len(frame_paths) != self.frames_per_scene:
                logger.warning(
                    f"[모션 생성] 장면 {idx+1}: 프레임 개수 불일치 "
                    f"(예상: {self.frames_per_scene}, 실제: {len(frame_paths)})"
                )
            
            # 장면에 모션 프레임 경로 추가
            scene['motion_frames_path'] = frame_paths
            scene['motion_frames_dir'] = str(Path(frame_paths[0]).parent) if frame_paths else ""
            updated_scenes.append(scene)
            
            logger.info(f"[모션 생성] 장면 {idx+1} 완료: {len(frame_paths)}개 프레임")
        
        logger.info(f"[모션 생성] 모든 모션 생성 완료")
        return updated_scenes


def node_motion_generator(state: Dict) -> Dict:
    """
    LangGraph 노드 함수: 모션 생성 (Wan2.2 I2V)
    
    Args:
        state: 현재 상태 딕셔너리
        
    Returns:
        업데이트된 상태 딕셔너리
    """
    try:
        scenes = state.get("scenes", [])
        if not scenes:
            raise ValueError("상태에 'scenes'가 없거나 비어있습니다.")
        
        topic = state.get("topic", "")
        output_dir = Config.get_output_dir(topic=topic)
        
        # 모션 생성 비활성화 옵션 확인
        if Config.MOTION_ENABLED:
            generator = MotionGenerator()
            updated_scenes = generator.generate_all_motions(scenes, output_dir)
        else:
            logger.info("[모션 생성] 모션 생성이 비활성화되어 있습니다. 스킵합니다.")
            updated_scenes = scenes
        
        return {
            **state,
            "scenes": updated_scenes
        }
        
    except RuntimeError as e:
        # 서버 연결 실패 등 명확한 에러는 사용자 친화적 메시지로 전달
        error_msg = str(e)
        if "접속할 수 없습니다" in error_msg or "연결할 수 없습니다" in error_msg:
            logger.error(f"[모션 생성 노드] ComfyUI 서버 연결 실패: {e}")
            raise RuntimeError(
                f"ComfyUI 서버에 연결할 수 없습니다.\n"
                f"서버를 수동으로 실행한 뒤 다시 시도해주세요.\n"
                f"상세: {error_msg}"
            ) from e
        raise
    except Exception as e:
        logger.error(f"[모션 생성 노드] 오류: {e}", exc_info=True)
        raise


================================================================================
File Path: .\tools\video_editor.py
================================================================================

"""
비디오 편집 도구 모듈
moviepy를 사용하여 이미지와 오디오를 결합하여 비디오를 생성합니다.
"""

import logging
import os
from pathlib import Path
from typing import Dict, List

import numpy as np
from moviepy import (
    ImageClip,
    AudioFileClip,
    VideoClip,
    ImageSequenceClip,
    concatenate_videoclips,
    CompositeVideoClip
)

from src.config import Config

logger = logging.getLogger(__name__)


def apply_ken_burns_effect(clip: ImageClip, duration: float, zoom_factor: float = None) -> ImageClip:
    """
    Ken Burns 효과 (Zoom-in)를 이미지 클립에 적용합니다.
    moviepy의 fl() 함수를 사용하여 프레임별로 줌 효과를 적용합니다.
    
    Args:
        clip: 이미지 클립
        duration: 클립 길이 (초)
        zoom_factor: 줌 인 팩터 (기본값: Config.ZOOM_FACTOR)
        
    Returns:
        효과가 적용된 클립
    """
    zoom_factor = zoom_factor or Config.ZOOM_FACTOR
    w, h = clip.size
    
    def make_frame(t):
        # 시간에 따라 선형적으로 줌 인
        progress = min(t / duration, 1.0) if duration > 0 else 0
        current_zoom = 1.0 + (zoom_factor - 1.0) * progress
        
        # 원본 프레임 가져오기
        frame = clip.get_frame(0)  # 정적 이미지이므로 항상 첫 프레임
        
        # 현재 줌에 따른 크롭 크기
        crop_w = int(w / current_zoom)
        crop_h = int(h / current_zoom)
        
        # 중앙에서 크롭할 위치 계산
        x_center = (w - crop_w) // 2
        y_center = (h - crop_h) // 2
        
        # 크롭
        cropped = frame[y_center:y_center+crop_h, x_center:x_center+crop_w]
        
        # 원본 크기로 리사이즈 (간단한 보간 사용)
        try:
            from PIL import Image
            img = Image.fromarray(cropped)
            img_resized = img.resize((w, h), Image.Resampling.LANCZOS)
            return np.array(img_resized)
        except ImportError:
            logger.warning("PIL이 설치되지 않아 간단한 리사이즈를 사용합니다.")
            # 간단한 리사이즈 (numpy만 사용)
            from scipy.ndimage import zoom as scipy_zoom
            zoom_ratio_w = w / crop_w
            zoom_ratio_h = h / crop_h
            resized = scipy_zoom(cropped, (zoom_ratio_h, zoom_ratio_w, 1), order=1)
            if resized.shape[0] != h or resized.shape[1] != w:
                resized = resized[:h, :w]
            return resized.astype(np.uint8)
    
    # 효과 적용 - 최신 moviepy에서는 VideoClip을 직접 생성
    try:
        zoomed_clip = VideoClip(make_frame)
        zoomed_clip = zoomed_clip.with_duration(duration)
        zoomed_clip = zoomed_clip.with_fps(Config.VIDEO_FPS)
    except Exception as e:
        logger.warning(f"Ken Burns 효과 적용 실패, 기본 이미지 사용: {e}")
        # 최종 폴백: 원본 이미지만 사용
        zoomed_clip = clip.with_duration(duration)
    
    return zoomed_clip


def create_video_clip_from_frames(frame_paths: List[str], audio_path: str, fps: int = None) -> VideoClip:
    """
    프레임 시퀀스와 오디오를 결합하여 비디오 클립을 생성합니다.
    
    Args:
        frame_paths: 프레임 파일 경로 리스트
        audio_path: 오디오 파일 경로
        fps: 프레임레이트 (기본값: Config.MOTION_FPS)
        
    Returns:
        오디오가 결합된 비디오 클립
        
    Raises:
        FileNotFoundError: 프레임 또는 오디오 파일이 없는 경우
        ValueError: 오디오 길이가 0이거나 프레임이 없는 경우
    """
    if not frame_paths:
        raise ValueError("프레임 경로 리스트가 비어있습니다.")
    
    if not os.path.exists(audio_path):
        raise FileNotFoundError(f"오디오 파일이 없습니다: {audio_path}")
    
    # 프레임 파일 존재 확인
    for frame_path in frame_paths:
        if not os.path.exists(frame_path):
            raise FileNotFoundError(f"프레임 파일이 없습니다: {frame_path}")
    
    fps = fps or Config.MOTION_FPS
    
    # 오디오 클립 로드
    try:
        audio_clip = AudioFileClip(audio_path)
        audio_duration = audio_clip.duration
        
        if audio_duration <= 0:
            raise ValueError(f"오디오 길이가 0입니다: {audio_path}")
        
        logger.debug(f"오디오 로드 완료: {audio_path} (길이: {audio_duration:.2f}초)")
    except Exception as e:
        logger.error(f"오디오 로드 실패 ({audio_path}): {e}")
        raise
    
    # 프레임 시퀀스에서 비디오 클립 생성
    try:
        logger.info(f"[비디오 편집] 프레임 시퀀스 클립 생성: {len(frame_paths)}개 프레임, FPS: {fps}")
        
        # ImageSequenceClip으로 프레임 시퀀스 생성
        video_clip = ImageSequenceClip(frame_paths, fps=fps)
        
        # 오디오 길이에 맞춰 클립 길이 조정
        if video_clip.duration > audio_duration:
            video_clip = video_clip.subclip(0, audio_duration)
        elif video_clip.duration < audio_duration:
            # 프레임이 부족하면 마지막 프레임 반복
            last_frame = frame_paths[-1]
            additional_frames_needed = int((audio_duration - video_clip.duration) * fps)
            extended_frames = frame_paths + [last_frame] * additional_frames_needed
            video_clip = ImageSequenceClip(extended_frames, fps=fps)
            video_clip = video_clip.subclip(0, audio_duration)
        
        # 오디오와 결합
        video_clip = video_clip.with_audio(audio_clip)
        video_clip = video_clip.with_fps(fps)
        
        logger.debug(f"프레임 시퀀스 비디오 클립 생성 완료: {len(frame_paths)}개 프레임, 길이: {video_clip.duration:.2f}초")
        return video_clip
        
    except Exception as e:
        logger.error(f"프레임 시퀀스 클립 생성 실패: {e}", exc_info=True)
        audio_clip.close()
        raise


def create_video_clip(image_path: str, audio_path: str, zoom_factor: float = None) -> ImageClip:
    """
    이미지와 오디오를 결합하여 비디오 클립을 생성합니다.
    
    Args:
        image_path: 이미지 파일 경로
        audio_path: 오디오 파일 경로
        zoom_factor: Ken Burns 효과 줌 팩터
        
    Returns:
        오디오가 결합된 이미지 클립
        
    Raises:
        FileNotFoundError: 이미지 또는 오디오 파일이 없는 경우
        ValueError: 오디오 길이가 0인 경우
    """
    # 파일 존재 확인
    if not os.path.exists(image_path):
        raise FileNotFoundError(f"이미지 파일이 없습니다: {image_path}")
    if not os.path.exists(audio_path):
        raise FileNotFoundError(f"오디오 파일이 없습니다: {audio_path}")
    
    # 오디오 클립 로드
    try:
        audio_clip = AudioFileClip(audio_path)
        audio_duration = audio_clip.duration
        
        if audio_duration <= 0:
            raise ValueError(f"오디오 길이가 0입니다: {audio_path}")
        
        logger.debug(f"오디오 로드 완료: {audio_path} (길이: {audio_duration:.2f}초)")
    except Exception as e:
        logger.error(f"오디오 로드 실패 ({audio_path}): {e}")
        raise
    
    # 이미지 클립 생성
    try:
        image_clip = ImageClip(image_path)
        image_clip = image_clip.with_duration(audio_duration)
        
        # Ken Burns 효과 적용
        zoom_factor = zoom_factor or Config.ZOOM_FACTOR
        image_clip = apply_ken_burns_effect(image_clip, audio_duration, zoom_factor)
        
        # 오디오와 결합
        video_clip = image_clip.with_audio(audio_clip)
        video_clip = video_clip.with_fps(Config.VIDEO_FPS)
        
        logger.debug(f"비디오 클립 생성 완료: {image_path}")
        return video_clip
        
    except Exception as e:
        logger.error(f"이미지 클립 생성 실패 ({image_path}): {e}")
        audio_clip.close()
        raise


def compose_video(scenes: List[Dict], output_path: Path) -> None:
    """
    모든 장면을 결합하여 최종 비디오를 생성합니다.
    모션 프레임이 있으면 사용하고, 없으면 정적 이미지 사용 (하위 호환성).
    
    Args:
        scenes: 장면 리스트 (motion_frames_path 또는 image_path 포함)
        output_path: 출력 비디오 파일 경로
        
    Raises:
        ValueError: 편집할 클립이 없는 경우
        Exception: 비디오 생성 실패 시
    """
    logger.info(f"[비디오 편집] {len(scenes)}개 장면 편집 시작")
    
    video_clips = []
    use_motion = Config.MOTION_ENABLED
    
    try:
        for idx, scene in enumerate(scenes):
            audio_path = scene.get('audio_path', '')
            motion_frames = scene.get('motion_frames_path', [])
            image_path = scene.get('image_path', '')
            
            # 파일 존재 확인
            if not audio_path:
                raise ValueError(f"장면 {idx+1}에 오디오 경로가 없습니다.")
            
            logger.info(f"[비디오 편집] 장면 {idx+1} 처리 중...")
            
            # 모션 프레임이 있으면 사용, 없으면 정적 이미지 사용
            if use_motion and motion_frames and len(motion_frames) > 0:
                logger.info(f"[비디오 편집] 장면 {idx+1}: 모션 프레임 사용 ({len(motion_frames)}개 프레임)")
                
                # 프레임 파일 존재 확인
                valid_frames = [f for f in motion_frames if os.path.exists(f)]
                if not valid_frames:
                    logger.warning(f"[비디오 편집] 장면 {idx+1}: 모션 프레임이 없어 정적 이미지로 폴백")
                    if not image_path:
                        raise ValueError(f"장면 {idx+1}에 이미지 경로도 없습니다.")
                    video_clip = create_video_clip(image_path, audio_path)
                else:
                    video_clip = create_video_clip_from_frames(valid_frames, audio_path, fps=Config.MOTION_FPS)
            else:
                # 정적 이미지 사용 (하위 호환성)
                if not image_path:
                    raise ValueError(f"장면 {idx+1}에 이미지 경로가 없습니다.")
                logger.info(f"[비디오 편집] 장면 {idx+1}: 정적 이미지 사용")
                video_clip = create_video_clip(image_path, audio_path)
            
            video_clips.append(video_clip)
            logger.info(f"[비디오 편집] 장면 {idx+1} 완료 (길이: {video_clip.duration:.2f}초, 프레임: {video_clip.fps if hasattr(video_clip, 'fps') else 'N/A'}fps)")
        
        if not video_clips:
            raise ValueError("편집할 비디오 클립이 없습니다.")
        
        # 모든 클립을 이어 붙이기
        logger.info(f"[비디오 편집] {len(video_clips)}개 클립 결합 중...")
        final_clip = concatenate_videoclips(video_clips, method="compose")
        
        # 최종 비디오 내보내기
        total_duration = final_clip.duration
        logger.info(f"[비디오 편집] 최종 비디오 내보내기 중... (길이: {total_duration:.2f}초)")
        
        output_dir = output_path.parent
        temp_audio_path = output_dir / 'temp_audio.m4a'
        
        # 모션 프레임 사용 시 해당 FPS 사용, 아니면 기본 FPS
        export_fps = Config.MOTION_FPS if use_motion else Config.VIDEO_FPS
        
        final_clip.write_videofile(
            str(output_path),
            fps=export_fps,
            codec=Config.VIDEO_CODEC,
            audio_codec=Config.VIDEO_AUDIO_CODEC,
            temp_audiofile=str(temp_audio_path),
            remove_temp=True
        )
        
        logger.info(f"[비디오 편집] 완료: {output_path}")
        
    finally:
        # 리소스 정리
        for clip in video_clips:
            try:
                clip.close()
            except Exception as e:
                logger.warning(f"클립 정리 실패: {e}")


def node_video_editor(state: Dict) -> Dict:
    """
    LangGraph 노드 함수: 비디오 편집
    
    Args:
        state: 현재 상태 딕셔너리
        
    Returns:
        업데이트된 상태 딕셔너리
    """
    try:
        scenes = state.get("scenes", [])
        if not scenes:
            raise ValueError("상태에 'scenes'가 없거나 비어있습니다.")
        
        topic = state.get("topic", "")
        output_dir = Config.get_output_dir(topic=topic)
        final_video_path = output_dir / "final_output.mp4"
        
        compose_video(scenes, final_video_path)
        
        return {
            **state,
            "final_video_path": str(final_video_path)
        }
        
    except Exception as e:
        logger.error(f"[비디오 편집 노드] 오류: {e}", exc_info=True)
        raise



================================================================================
File Path: .\tools\__init__.py
================================================================================

"""도구 모듈"""



================================================================================
File Path: .\utils\cache.py
================================================================================

"""
캐싱 유틸리티 모듈
워크플로우 단계별 결과물을 캐싱하여 재실행 시 시간을 절약합니다.
"""

import hashlib
import json
import logging
import os
from pathlib import Path
from typing import Dict, Any, Optional

from src.config import Config

logger = logging.getLogger(__name__)


class WorkflowCache:
    """워크플로우 캐시 관리 클래스"""
    
    CACHE_FILE = "workflow_cache.json"
    
    # 캐시 단계 정의
    STAGE_SCRIPT = "script"
    STAGE_AUDIO = "audio"
    STAGE_IMAGE = "image"
    STAGE_MOTION = "motion"
    STAGE_VIDEO = "video"
    
    def __init__(self, topic: str):
        """
        캐시 초기화
        
        Args:
            topic: 비디오 주제 (캐시 키로 사용)
        """
        self.topic = topic
        self.topic_hash = self._hash_topic(topic)
        # 캐시는 주제별 폴더 안에 저장
        self.cache_dir = Config.get_output_dir(topic=topic) / "cache"
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        self.cache_file = self.cache_dir / f"{self.topic_hash}.json"
        self.cache_data = self._load_cache()
        
    def _hash_topic(self, topic: str) -> str:
        """주제를 해시하여 캐시 키 생성"""
        return hashlib.md5(topic.encode('utf-8')).hexdigest()[:12]
    
    def _load_cache(self) -> Dict[str, Any]:
        """캐시 파일 로드"""
        if self.cache_file.exists():
            try:
                with open(self.cache_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    # 주제가 일치하는지 확인
                    if data.get("topic") == self.topic:
                        logger.info(f"[캐시] 기존 캐시 로드: {self.cache_file.name}")
                        return data
                    else:
                        logger.info("[캐시] 주제가 변경되어 캐시 무효화")
            except Exception as e:
                logger.warning(f"[캐시] 캐시 로드 실패: {e}")
        
        return {"topic": self.topic, "stages": {}}
    
    def _save_cache(self) -> None:
        """캐시 파일 저장"""
        try:
            with open(self.cache_file, 'w', encoding='utf-8') as f:
                json.dump(self.cache_data, f, ensure_ascii=False, indent=2)
            logger.debug(f"[캐시] 저장 완료: {self.cache_file.name}")
        except Exception as e:
            logger.warning(f"[캐시] 저장 실패: {e}")
    
    def get_stage(self, stage: str) -> Optional[Dict[str, Any]]:
        """
        캐시된 단계 데이터 조회
        
        Args:
            stage: 단계 이름 (script, audio, image, video)
            
        Returns:
            캐시된 데이터 또는 None
        """
        stage_data = self.cache_data.get("stages", {}).get(stage)
        
        if stage_data:
            # 파일 존재 여부 확인 (audio, image, motion, video 단계)
            if stage in [self.STAGE_AUDIO, self.STAGE_IMAGE, self.STAGE_MOTION]:
                scenes = stage_data.get("scenes", [])
                for scene in scenes:
                    if stage == self.STAGE_AUDIO:
                        path_key = "audio_path"
                    elif stage == self.STAGE_IMAGE:
                        path_key = "image_path"
                    else:  # STAGE_MOTION
                        # 모션 프레임 경로 확인
                        motion_frames = scene.get("motion_frames_path", [])
                        if motion_frames:
                            for frame_path in motion_frames:
                                if frame_path and not os.path.exists(frame_path):
                                    logger.info(f"[캐시] 모션 프레임이 없어 캐시 무효화: {frame_path}")
                                    return None
                        continue
                    
                    path = scene.get(path_key)
                    if path and not os.path.exists(path):
                        logger.info(f"[캐시] 파일이 없어 캐시 무효화: {path}")
                        return None
            elif stage == self.STAGE_VIDEO:
                video_path = stage_data.get("final_video_path")
                if video_path and not os.path.exists(video_path):
                    logger.info(f"[캐시] 비디오 파일이 없어 캐시 무효화: {video_path}")
                    return None
            
            logger.info(f"[캐시] {stage} 단계 캐시 히트!")
            return stage_data
        
        return None
    
    def set_stage(self, stage: str, data: Dict[str, Any]) -> None:
        """
        단계 데이터 캐시 저장
        
        Args:
            stage: 단계 이름
            data: 저장할 데이터
        """
        if "stages" not in self.cache_data:
            self.cache_data["stages"] = {}
        
        self.cache_data["stages"][stage] = data
        self._save_cache()
        logger.info(f"[캐시] {stage} 단계 캐시 저장")
    
    def clear(self) -> None:
        """캐시 초기화"""
        self.cache_data = {"topic": self.topic, "stages": {}}
        if self.cache_file.exists():
            self.cache_file.unlink()
        logger.info("[캐시] 캐시 초기화 완료")
    
    def get_status(self) -> Dict[str, bool]:
        """각 단계별 캐시 상태 반환"""
        stages = [self.STAGE_SCRIPT, self.STAGE_AUDIO, self.STAGE_IMAGE, self.STAGE_MOTION, self.STAGE_VIDEO]
        return {stage: self.get_stage(stage) is not None for stage in stages}


# 전역 캐시 인스턴스 (main에서 초기화)
_cache_instance: Optional[WorkflowCache] = None


def init_cache(topic: str) -> WorkflowCache:
    """캐시 초기화 및 전역 인스턴스 설정"""
    global _cache_instance
    _cache_instance = WorkflowCache(topic)
    return _cache_instance


def get_cache() -> Optional[WorkflowCache]:
    """전역 캐시 인스턴스 반환"""
    return _cache_instance


================================================================================
File Path: .\utils\json_parser.py
================================================================================

"""
JSON 파싱 유틸리티 모듈
LLM 출력에서 JSON을 안전하게 추출합니다.
"""

import json
import re
import logging

logger = logging.getLogger(__name__)


def extract_json_from_text(text: str) -> dict:
    """
    LLM 출력에서 JSON을 추출합니다.
    DeepSeek R1의 <think>, <think> 태그를 제거하고 JSON만 추출합니다.
    
    Args:
        text: LLM이 반환한 텍스트
        
    Returns:
        파싱된 JSON 딕셔너리
        
    Raises:
        ValueError: JSON을 찾을 수 없거나 파싱에 실패한 경우
    """
    if not text or not isinstance(text, str):
        raise ValueError("입력 텍스트가 유효하지 않습니다.")
    
    original_text = text
    
    # <think> 태그와 내용 제거
    text = re.sub(r'<think>.*?</think>', '', text, flags=re.DOTALL | re.IGNORECASE)
    
    # <think> 태그와 내용 제거
    text = re.sub(r'<think>.*?</think>', '', text, flags=re.DOTALL | re.IGNORECASE)
    
    # JSON 코드 블록 찾기 (```json ... ``` 또는 ``` ... ```)
    json_match = re.search(r'```(?:json)?\s*(\{.*?\})\s*```', text, re.DOTALL)
    if json_match:
        json_text = json_match.group(1)
    else:
        # JSON 객체 직접 찾기 ({ ... })
        json_match = re.search(r'\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}', text, re.DOTALL)
        if json_match:
            json_text = json_match.group(0)
        else:
            logger.error(f"JSON을 찾을 수 없습니다. 원본 텍스트: {original_text[:500]}")
            raise ValueError(f"JSON을 찾을 수 없습니다. 텍스트 길이: {len(original_text)}")
    
    try:
        parsed = json.loads(json_text)
        logger.debug(f"JSON 파싱 성공: {len(json.dumps(parsed))} 문자")
        return parsed
    except json.JSONDecodeError as e:
        logger.error(f"JSON 파싱 실패: {e}\n시도한 JSON 텍스트: {json_text[:500]}")
        raise ValueError(f"JSON 파싱 실패: {e}\n원본 텍스트 일부: {original_text[:500]}")



================================================================================
File Path: .\utils\logger.py
================================================================================

"""
로깅 유틸리티 모듈
"""

import logging
import sys
from pathlib import Path


def setup_logger(name: str = "langgraph-automator", level: int = logging.INFO) -> logging.Logger:
    """
    로거를 설정하고 반환합니다.
    
    Args:
        name: 로거 이름
        level: 로깅 레벨
        
    Returns:
        설정된 로거 인스턴스
    """
    logger = logging.getLogger(name)
    logger.setLevel(level)
    
    # 중복 핸들러 방지
    if logger.handlers:
        return logger
    
    # 콘솔 핸들러
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(level)
    
    # 포맷터
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    console_handler.setFormatter(formatter)
    
    logger.addHandler(console_handler)
    
    # 파일 핸들러 (선택적)
    log_dir = Path("logs")
    log_dir.mkdir(exist_ok=True)
    file_handler = logging.FileHandler(log_dir / "automator.log", encoding='utf-8')
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)
    
    return logger



================================================================================
File Path: .\utils\__init__.py
================================================================================

"""유틸리티 모듈"""



================================================================================
File Path: .\workflow\graph.py
================================================================================

"""
LangGraph 워크플로우 정의 모듈
상태 정의, 노드 등록, 그래프 구성을 담당합니다.
"""

import logging
from typing import TypedDict, List, Dict, Annotated
from functools import wraps

from langgraph.graph import StateGraph, END
from langgraph.checkpoint.memory import MemorySaver

from src.agents.script_writer import node_script_writer
from src.agents.tts import node_audio_generator
from src.agents.vision import node_visual_generator
from src.tools.motion_gen import node_motion_generator
from src.tools.video_editor import node_video_editor
from src.utils.cache import get_cache, WorkflowCache

logger = logging.getLogger(__name__)


# ============================================================================
# 상태 정의
# ============================================================================

class VideoState(TypedDict):
    """
    비디오 생성 워크플로우의 상태를 관리하는 TypedDict
    """
    topic: str
    scenes: List[Dict[str, str]]
    final_video_path: str


# ============================================================================
# 재시도 데코레이터
# ============================================================================

def retry_node(max_retries: int = 2, delay: float = 1.0):
    """노드 함수에 재시도 로직을 추가하는 데코레이터"""
    def decorator(func):
        @wraps(func)
        def wrapper(state: VideoState) -> VideoState:
            last_error = None
            
            for attempt in range(max_retries + 1):
                try:
                    logger.debug(f"{func.__name__} 실행 (시도 {attempt + 1}/{max_retries + 1})")
                    return func(state)
                except Exception as e:
                    last_error = e
                    if attempt < max_retries:
                        import time
                        wait_time = delay * (attempt + 1)
                        logger.warning(
                            f"{func.__name__} 실패 (시도 {attempt + 1}/{max_retries + 1}), "
                            f"{wait_time:.1f}초 후 재시도: {e}"
                        )
                        time.sleep(wait_time)
                    else:
                        logger.error(f"{func.__name__} 최종 실패: {e}", exc_info=True)
            raise last_error
        return wrapper
    return decorator


# ============================================================================
# 캐시 데코레이터
# ============================================================================

def with_cache(stage: str, result_keys: List[str]):
    """
    노드에 캐싱 로직을 추가하는 데코레이터
    
    Args:
        stage: 캐시 단계 이름
        result_keys: 캐시할 상태 키 목록
    """
    def decorator(func):
        @wraps(func)
        def wrapper(state: VideoState) -> VideoState:
            cache = get_cache()
            
            # 캐시 확인
            if cache:
                cached = cache.get_stage(stage)
                if cached:
                    logger.info(f"[{stage}] 캐시에서 로드 (스킵)")
                    result = {**state}
                    for key in result_keys:
                        if key in cached:
                            result[key] = cached[key]
                    return result
            
            # 실제 실행
            result = func(state)
            
            # 캐시 저장
            if cache:
                cache_data = {key: result.get(key) for key in result_keys}
                cache.set_stage(stage, cache_data)
            
            return result
        return wrapper
    return decorator


# ============================================================================
# 노드 래퍼 (캐싱 + 재시도)
# ============================================================================

@with_cache(WorkflowCache.STAGE_SCRIPT, ["scenes"])
@retry_node(max_retries=2, delay=2.0)
def node_script_writer_with_retry(state: VideoState) -> VideoState:
    """대본 작성 노드 (캐싱 + 재시도)"""
    return node_script_writer(state)


@with_cache(WorkflowCache.STAGE_AUDIO, ["scenes"])
@retry_node(max_retries=2, delay=1.0)
def node_audio_generator_with_retry(state: VideoState) -> VideoState:
    """오디오 생성 노드 (캐싱 + 재시도)"""
    return node_audio_generator(state)


@with_cache(WorkflowCache.STAGE_IMAGE, ["scenes"])
@retry_node(max_retries=2, delay=3.0)
def node_visual_generator_with_retry(state: VideoState) -> VideoState:
    """이미지 생성 노드 (캐싱 + 재시도)"""
    return node_visual_generator(state)


@with_cache(WorkflowCache.STAGE_MOTION, ["scenes"])
@retry_node(max_retries=2, delay=3.0)
def node_motion_generator_with_retry(state: VideoState) -> VideoState:
    """모션 생성 노드 (캐싱 + 재시도)"""
    return node_motion_generator(state)


@with_cache(WorkflowCache.STAGE_VIDEO, ["final_video_path"])
@retry_node(max_retries=1, delay=2.0)
def node_video_editor_with_retry(state: VideoState) -> VideoState:
    """비디오 편집 노드 (캐싱 + 재시도)"""
    return node_video_editor(state)


# ============================================================================
# 그래프 구성
# ============================================================================

def create_video_graph(checkpoint: bool = False) -> StateGraph:
    """
    LangGraph StateGraph를 생성하고 노드들을 연결합니다.
    
    Args:
        checkpoint: 체크포인트 사용 여부 (메모리 기반)
        
    Returns:
        컴파일된 StateGraph
    """
    logger.info("비디오 생성 그래프 구성 중...")
    
    # 그래프 생성
    if checkpoint:
        memory = MemorySaver()
        workflow = StateGraph(VideoState).compile(checkpointer=memory)
    else:
        workflow = StateGraph(VideoState)
    
    # 노드 추가
    workflow.add_node("script_writer", node_script_writer_with_retry)
    workflow.add_node("audio_generator", node_audio_generator_with_retry)
    workflow.add_node("visual_generator", node_visual_generator_with_retry)
    workflow.add_node("motion_generator", node_motion_generator_with_retry)
    workflow.add_node("video_editor", node_video_editor_with_retry)
    
    # 엣지 연결 (순차 실행)
    workflow.set_entry_point("script_writer")
    workflow.add_edge("script_writer", "audio_generator")
    workflow.add_edge("audio_generator", "visual_generator")
    workflow.add_edge("visual_generator", "motion_generator")  # 이미지 생성 후 모션 생성
    workflow.add_edge("motion_generator", "video_editor")  # 모션 생성 후 비디오 편집
    workflow.add_edge("video_editor", END)
    
    # 컴파일
    if not checkpoint:
        workflow = workflow.compile()
    
    logger.info("비디오 생성 그래프 구성 완료")
    return workflow


def create_video_graph_simple() -> StateGraph:
    """간단한 버전의 그래프 생성 (체크포인트 없음)"""
    return create_video_graph(checkpoint=False)


================================================================================
File Path: .\workflow\__init__.py
================================================================================

"""워크플로우 모듈"""

